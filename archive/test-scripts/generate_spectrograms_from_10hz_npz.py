#!/usr/bin/env python3
"""
Generate daily spectrograms from 10 Hz decimated NPZ files

Reads 10 Hz IQ carrier data from analytics decimated directory and generates
spectrogram PNGs for web UI display.

Much faster than Digital RF approach since:
- Files already exist (generated by analytics service)
- Smaller file size (10 Hz vs 16 kHz)
- No Digital RF dependency
- Perfect for carrier visualization (±5 Hz range)

Usage:
    python3 scripts/generate_spectrograms_from_10hz_npz.py --date 20251116
"""

import argparse
import logging
import sys
from pathlib import Path
from datetime import datetime, timezone, timedelta
from typing import Optional, Tuple, List
import numpy as np

# Add parent to path
sys.path.insert(0, str(Path(__file__).parent.parent))
from src.signal_recorder.paths import get_paths, GRAPEPaths

try:
    import matplotlib
    matplotlib.use('Agg')  # Non-interactive backend
    import matplotlib.pyplot as plt
    from matplotlib.dates import DateFormatter
    MPL_AVAILABLE = True
except ImportError:
    MPL_AVAILABLE = False
    print("ERROR: matplotlib package required")
    exit(1)

from scipy import signal as scipy_signal

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def find_10hz_npz_files(decimated_dir: Path, date_str: str) -> List[Path]:
    """
    Find all 10 Hz NPZ files for a specific date
    
    Args:
        decimated_dir: Channel decimated directory
        date_str: Date in YYYYMMDD format
        
    Returns:
        Sorted list of 10 Hz NPZ file paths
    """
    if not decimated_dir.exists():
        logger.warning(f"Decimated directory not found: {decimated_dir}")
        return []
    
    # 10 Hz NPZ files: YYYYMMDDTHHMMSSZ_freq_iq_10hz.npz
    npz_files = sorted(decimated_dir.glob(f"{date_str}*_10hz.npz"))
    
    logger.info(f"Found {len(npz_files)} 10Hz NPZ files for {date_str}")
    return npz_files


def read_10hz_day(npz_files: List[Path]) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:
    """
    Read and concatenate 10 Hz NPZ files for a full day
    
    Args:
        npz_files: List of 10 Hz NPZ file paths (sorted)
        
    Returns:
        (timestamps, iq_samples, sample_rate) or None
    """
    if not npz_files:
        return None
    
    all_timestamps = []
    all_samples = []
    sample_rate = 10.0  # 10 Hz decimated data
    
    logger.info(f"Reading {len(npz_files)} 10Hz NPZ files...")
    
    for i, npz_file in enumerate(npz_files):
        try:
            data = np.load(npz_file)
            iq = data['iq']  # 10 Hz decimated IQ data
            
            # Parse timestamp from filename: YYYYMMDDTHHMMSSZ_freq_iq_10hz.npz
            filename = npz_file.name
            timestamp_str = filename.split('_')[0]  # YYYYMMDDTHHMMSSZ
            dt = datetime.strptime(timestamp_str, '%Y%m%dT%H%M%SZ')
            dt = dt.replace(tzinfo=timezone.utc)
            file_unix_ts = dt.timestamp()
            
            # Generate timestamps for this file
            num_samples = len(iq)
            file_timestamps = file_unix_ts + np.arange(num_samples) / sample_rate
            
            all_timestamps.append(file_timestamps)
            all_samples.append(iq)
            
            if (i + 1) % 100 == 0:
                logger.info(f"  Processed {i + 1}/{len(npz_files)} files...")
                
        except Exception as e:
            logger.warning(f"Failed to read {npz_file.name}: {e}")
            continue
    
    if not all_samples:
        logger.error("No valid samples loaded")
        return None
    
    # Concatenate all data
    timestamps = np.concatenate(all_timestamps)
    iq_samples = np.concatenate(all_samples)
    
    hours_of_data = iq_samples.size / sample_rate / 3600.0
    logger.info(f"✅ Loaded {iq_samples.size:,} samples @ {sample_rate} Hz ({hours_of_data:.1f} hours)")
    
    return timestamps, iq_samples, sample_rate


def generate_spectrogram(timestamps: np.ndarray, iq_samples: np.ndarray,
                        sample_rate: float, output_path: Path,
                        channel_name: str, date_str: str):
    """
    Generate carrier spectrogram PNG from 10 Hz IQ samples
    
    Args:
        timestamps: Unix timestamps for each sample
        iq_samples: Complex IQ samples at 10 Hz
        sample_rate: Sample rate (10 Hz)
        output_path: Path to save PNG
        channel_name: Channel name for title
        date_str: Date string (YYYY-MM-DD)
    """
    try:
        logger.info(f"Generating spectrogram for {len(iq_samples):,} samples...")
        
        # Spectrogram parameters for 10 Hz carrier data
        nperseg = min(512, len(iq_samples))  # 51.2 second windows
        noverlap = nperseg // 2
        
        # Compute spectrogram
        f, t, Sxx = scipy_signal.spectrogram(
            iq_samples,
            fs=sample_rate,
            window='hann',
            nperseg=nperseg,
            noverlap=noverlap,
            scaling='density',
            mode='psd'
        )
        
        # Convert to dB
        Sxx_db = 10 * np.log10(Sxx + 1e-10)
        
        # Create figure
        fig, ax = plt.subplots(figsize=(16, 6), dpi=100)
        
        # Parse date for full 24-hour axis
        year, month, day = int(date_str[:4]), int(date_str[5:7]), int(date_str[8:10])
        day_start = datetime(year, month, day, 0, 0, 0, tzinfo=timezone.utc)
        day_end = datetime(year, month, day, 23, 59, 59, tzinfo=timezone.utc)
        day_start_ts = day_start.timestamp()
        day_end_ts = day_end.timestamp()
        
        # Calculate coverage
        data_start = datetime.fromtimestamp(timestamps[0], tz=timezone.utc)
        data_end = datetime.fromtimestamp(timestamps[-1], tz=timezone.utc)
        hours_covered = (timestamps[-1] - timestamps[0]) / 3600
        coverage_str = f"Coverage: {data_start.strftime('%H:%M')} - {data_end.strftime('%H:%M')} UTC ({hours_covered:.1f} hrs)"
        
        # Map spectrogram time bins to actual UTC timestamps
        # The spectrogram 't' array is relative to input array, but we need actual UTC times
        # Resample the timestamps array to match spectrogram time resolution
        data_times = np.interp(t, np.arange(len(timestamps)) / sample_rate, timestamps)
        
        # Create full 24-hour time grid (5 minute resolution for display)
        time_resolution = 300  # 5 minutes in seconds
        full_time_grid = np.arange(day_start_ts, day_end_ts + time_resolution, time_resolution)
        full_datetime_grid = [datetime.fromtimestamp(ts, tz=timezone.utc) for ts in full_time_grid]
        
        # Shift frequencies to center at 0
        f_shifted = np.fft.fftshift(f)
        Sxx_db_shifted = np.fft.fftshift(Sxx_db, axes=0)
        
        # Create output spectrogram array with NaN for missing data
        num_freqs = len(f_shifted)
        num_time_bins = len(full_time_grid)
        Sxx_full = np.full((num_freqs, num_time_bins), np.nan)
        
        # Map data to correct time bins in full grid
        for i, data_t in enumerate(data_times):
            # Find closest time bin in full grid
            time_idx = np.argmin(np.abs(full_time_grid - data_t))
            if time_idx < num_time_bins and np.abs(full_time_grid[time_idx] - data_t) < time_resolution:
                Sxx_full[:, time_idx] = Sxx_db_shifted[:, i]
        
        # Adaptive color scaling for maximum contrast
        vmin = np.nanpercentile(Sxx_db_shifted, 1)
        vmax = np.nanpercentile(Sxx_db_shifted, 99)
        
        logger.info(f"Color scale: {vmin:.1f} to {vmax:.1f} dB")
        logger.info(f"Full grid: {len(full_time_grid)} time bins, {np.sum(~np.isnan(Sxx_full[0]))} with data")
        
        # Plot spectrogram with full 24-hour grid
        im = ax.pcolormesh(
            full_datetime_grid,
            f_shifted,
            Sxx_full,
            shading='nearest',
            cmap='viridis',
            vmin=vmin,
            vmax=vmax
        )
        
        # Format axes
        ax.set_ylabel('Frequency Offset (Hz)', fontsize=12)
        ax.set_xlabel('Time (UTC)', fontsize=12)
        ax.set_title(
            f'{channel_name} - {date_str} - Carrier Spectrogram (10 Hz IQ)\n{coverage_str}',
            fontsize=14, fontweight='bold'
        )
        
        # Set x-axis to full 24-hour day
        ax.set_xlim(day_start, day_end)
        
        # Format x-axis
        ax.xaxis.set_major_formatter(DateFormatter('%H:%M'))
        ax.grid(True, alpha=0.3, linestyle='--', linewidth=0.5)
        fig.autofmt_xdate()
        
        # Colorbar
        cbar = fig.colorbar(im, ax=ax, label='Power (dB)')
        
        # Save
        plt.tight_layout()
        plt.savefig(output_path, dpi=100, bbox_inches='tight')
        plt.close()
        
        logger.info(f"✅ Saved spectrogram: {output_path}")
        
    except Exception as e:
        logger.error(f"Failed to generate spectrogram: {e}", exc_info=True)
        raise


def main():
    parser = argparse.ArgumentParser(description='Generate spectrograms from 10 Hz NPZ files')
    parser.add_argument('--date', required=True, help='Date (YYYYMMDD)')
    parser.add_argument('--data-root', default='/tmp/grape-test', help='Data root directory')
    parser.add_argument('--channel', help='Specific channel (e.g. "WWV 10 MHz")')
    parser.add_argument('--include-carrier', action='store_true', help='Include carrier channels (now using analytics decimated files)')
    
    args = parser.parse_args()
    
    # Initialize paths
    paths = get_paths(data_root=Path(args.data_root))
    
    # Format date
    date_obj = datetime.strptime(args.date, '%Y%m%d')
    date_str = date_obj.strftime('%Y-%m-%d')
    
    logger.info(f"{'='*60}")
    logger.info(f"Generating spectrograms from 10 Hz NPZ files")
    logger.info(f"Date: {date_str}")
    logger.info(f"Data root: {args.data_root}")
    logger.info(f"{'='*60}\n")
    
    # Get channels
    if args.channel:
        channels = [args.channel]
    else:
        channels = paths.discover_channels()
    
    success_count = 0
    total_count = 0
    
    for channel_name in channels:
        # Skip carrier channels unless --include-carrier specified
        # With analytics running, carrier channels now have decimated files too (200 Hz → 10 Hz via IIR)
        if 'carrier' in channel_name and not args.include_carrier:
            logger.info(f"Skipping {channel_name} (use --include-carrier to process)")
            continue
            
        total_count += 1
        is_carrier = 'carrier' in channel_name
        logger.info(f"\n{'='*60}")
        logger.info(f"Channel: {channel_name}")
        logger.info(f"{'='*60}")
        
        try:
            # Get decimated directory
            # Path: {data_root}/analytics/{channel_dir}/decimated/
            channel_dir = channel_name.replace(' ', '_')
            decimated_dir = Path(args.data_root) / 'analytics' / channel_dir / 'decimated'
            
            # Find 10 Hz NPZ files
            npz_files = find_10hz_npz_files(decimated_dir, args.date)
            
            if not npz_files:
                logger.warning(f"No 10 Hz NPZ files found for {channel_name}")
                continue
            
            # Read data
            result = read_10hz_day(npz_files)
            if not result:
                logger.error(f"Failed to read data for {channel_name}")
                continue
            
            timestamps, iq_samples, sample_rate = result
            
            # Create output directory
            # Carrier channels: native-carrier (200Hz→10Hz)
            # Wide channels: wide-decimated (16kHz→10Hz)
            subdirectory = 'native-carrier' if is_carrier else 'wide-decimated'
            output_dir = Path(args.data_root) / 'spectrograms' / args.date / subdirectory
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Generate spectrogram with clear naming
            safe_channel_name = channel_name.replace(' ', '_')
            source_rate = '200Hz' if is_carrier else '16kHz'
            output_path = output_dir / f'{safe_channel_name}_10Hz_from_{source_rate}.png'
            
            generate_spectrogram(
                timestamps, iq_samples, sample_rate,
                output_path, channel_name, date_str
            )
            
            success_count += 1
            
        except Exception as e:
            logger.error(f"Error processing {channel_name}: {e}", exc_info=True)
            continue
    
    logger.info(f"\n{'='*60}")
    logger.info(f"✅ Generated {success_count}/{total_count} spectrograms")
    logger.info(f"{'='*60}")
    
    return 0 if success_count == total_count else 1


if __name__ == '__main__':
    exit(main())
