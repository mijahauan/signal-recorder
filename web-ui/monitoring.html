<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRAPE Recorder Monitor</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
        }
        
        /* Navigation bar */
        .navbar {
            background: #2c3e50;
            color: white;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .navbar h2 {
            margin: 0;
            font-size: 20px;
        }
        .navbar .nav-links {
            display: flex;
            gap: 15px;
        }
        .navbar a {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 4px;
            transition: background 0.3s;
        }
        .navbar a:hover {
            background: rgba(255,255,255,0.1);
        }
        .navbar a.active {
            background: rgba(255,255,255,0.2);
            font-weight: 600;
        }
        
        /* Tab Navigation */
        .tabs {
            background: white;
            padding: 0 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            display: flex;
            gap: 5px;
            border-bottom: 2px solid #e0e0e0;
        }
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 15px;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        .tab:hover {
            color: #333;
            background: #f8f8f8;
        }
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: 600;
        }
        
        /* Tab Panels */
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }
        
        .content {
            padding: 20px;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .header h1 { margin: 0 0 5px 0; }
        .header p { margin: 0; opacity: 0.9; }
        
        /* System-wide status summary */
        .system-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .summary-card h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .summary-card .value {
            font-size: 28px;
            font-weight: bold;
            color: #333;
        }
        .summary-card .subtext {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }
        
        /* Health indicators */
        .health-summary {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .health-indicators {
            display: flex;
            gap: 30px;
            align-items: center;
        }
        .health-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        .health-badge .count {
            font-size: 24px;
        }
        
        /* Controls */
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }
        .btn-refresh {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        .btn-refresh:hover { background: #5a6fd8; }
        
        .daemon-status-bar {
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .daemon-status-bar .status {
            font-size: 16px;
            font-weight: 600;
        }
        .daemon-status-bar .status.running { color: #4CAF50; }
        .daemon-status-bar .status.stopped { color: #f44336; }
        
        /* Channel cards */
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .channel-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #ccc;
        }
        .channel-card.healthy { border-left-color: #4CAF50; }
        .channel-card.warning { border-left-color: #ff9800; }
        .channel-card.error { border-left-color: #f44336; }
        
        .channel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .channel-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        .channel-freq {
            font-size: 14px;
            color: #666;
        }
        .health-indicator {
            font-size: 24px;
        }
        
        .channel-status {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #666;
        }
        
        .metrics-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }
        .metric {
            font-size: 13px;
        }
        .metric-label {
            color: #666;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .metric-value {
            font-weight: bold;
            color: #333;
            font-size: 15px;
        }
        .metric-value.good { color: #4CAF50; }
        .metric-value.warning { color: #ff9800; }
        .metric-value.error { color: #f44336; }
        
        /* Data Quality Section */
        .quality-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .quality-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .quality-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .quality-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .quality-icon {
            font-size: 24px;
        }
        .quality-metric {
            flex: 1;
        }
        .quality-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .quality-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        .quality-value.excellent { color: #4CAF50; }
        .quality-value.good { color: #8BC34A; }
        .quality-value.fair { color: #ff9800; }
        .quality-value.poor { color: #f44336; }
        .quality-details {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px;
            font-size: 13px;
            color: #666;
        }
        .quality-issue {
            padding: 8px 12px;
            margin: 5px 0;
            border-left: 3px solid #ff9800;
            background: #fff3e0;
            border-radius: 4px;
            font-size: 13px;
        }
        .quality-issue.error {
            border-left-color: #f44336;
            background: #ffebee;
        }
        
        /* Summary Table */
        .summary-table-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px 0;
            overflow-x: auto;
        }
        .summary-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        .summary-table th {
            background: #f8f9fa;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #666;
            border-bottom: 2px solid #dee2e6;
            cursor: pointer;
            user-select: none;
        }
        .summary-table th:hover {
            background: #e9ecef;
        }
        .summary-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #e9ecef;
        }
        .summary-table tr:hover {
            background: #f8f9fa;
        }
        .summary-table .channel-name {
            font-weight: 500;
            color: #333;
        }
        .summary-table .metric-good {
            color: #4CAF50;
            font-weight: 500;
        }
        .summary-table .metric-warning {
            color: #ff9800;
            font-weight: 500;
        }
        .summary-table .metric-error {
            color: #f44336;
            font-weight: 500;
        }
        
        /* WWV Validation Cards */
        .wwv-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        .wwv-section h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #333;
        }
        .wwv-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .wwv-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .wwv-card h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            opacity: 0.9;
        }
        .wwv-card .value {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
        }
        .wwv-card .subtext {
            font-size: 12px;
            opacity: 0.8;
        }
        
        /* Logs */
        .logs-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .logs-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 6px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
        }
        .log-line { padding: 2px 0; }
        .log-line.error { color: #f48771; }
        .log-line.warning { color: #dcdcaa; }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
            font-style: italic;
        }
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
        }
        
        /* Listen button hover effect */
        .listen-btn:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            transform: scale(1.1);
        }
        
        /* Pulse animation for active audio button */
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.8), 0 0 30px rgba(76, 175, 80, 0.4);
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <h2>📡 GRAPE Signal Recorder</h2>
        <div class="nav-links">
            <a href="/">⚙️ Configuration</a>
            <a href="/monitoring.html" class="active">📊 Monitoring</a>
        </div>
    </nav>

    <!-- Tab Navigation -->
    <div class="tabs">
        <button class="tab active" onclick="switchTab('dashboard')">📊 Dashboard</button>
        <button class="tab" onclick="switchTab('channels')">📡 Channels</button>
    </div>

    <div class="content">
        <div id="auth-error" style="display: none; background: #fee; color: #c00; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #fcc;">
            <strong>⚠️ Authentication Error:</strong> <span id="auth-error-message"></span>
            <br><small>Please ensure you're logged in via the <a href="/" style="color: #c00; text-decoration: underline;">Configuration page</a> first.</small>
        </div>
        
        <div class="header">
            <h1>📊 Live Monitoring Dashboard</h1>
            <p>Real-time recording status and metrics • Auto-refreshes every 30s</p>
        </div>

        <div class="daemon-status-bar">
            <div>
                <span style="color: #666; font-size: 14px;">Daemon Status:</span>
                <span id="daemon-status-text" class="status">Checking...</span>
            </div>
            <button class="btn-refresh" onclick="refreshAll()">🔄 Refresh Now</button>
        </div>

        <!-- Dashboard Tab Panel -->
        <div id="dashboard-panel" class="tab-panel active">

    <div class="health-summary" id="health-summary" style="display: none;">
        <div class="health-indicators">
            <div class="health-badge">
                🟢 <span class="count" id="healthy-count">0</span> Healthy
            </div>
            <div class="health-badge">
                🟡 <span class="count" id="warning-count">0</span> Warning
            </div>
            <div class="health-badge">
                🔴 <span class="count" id="error-count">0</span> Error
            </div>
        </div>
        <div style="text-align: right; color: #666; font-size: 14px;">
            <div><strong id="packet-loss-pct">0.00%</strong> Packet Loss</div>
        </div>
    </div>

    <div class="system-summary" id="system-summary" style="display: none;">
        <div class="summary-card">
            <h3>Recording Time</h3>
            <div class="value" id="recording-duration">0m</div>
            <div class="subtext">Active recording session</div>
        </div>
        <div class="summary-card">
            <h3>Total Data</h3>
            <div class="value" id="total-data">0 MB</div>
            <div class="subtext">Across all channels</div>
        </div>
        <div class="summary-card">
            <h3>Packets Received</h3>
            <div class="value" id="total-packets">0</div>
            <div class="subtext" id="packets-per-sec">0/sec</div>
        </div>
        <div class="summary-card">
            <h3>Active Channels</h3>
            <div class="value" id="channel-count">0</div>
            <div class="subtext">Recording streams</div>
        </div>
    </div>

    <!-- Data Quality Validation Section -->
    <div class="quality-section" id="quality-section" style="display: none;">
        <h2 style="margin: 0 0 15px 0; font-size: 18px; color: #333;">📊 Data Quality Validation</h2>
        <div class="quality-grid">
            <div class="quality-card">
                <div class="quality-icon">✅</div>
                <div class="quality-metric">
                    <div class="quality-label">Overall Quality</div>
                    <div class="quality-value" id="quality-score">--</div>
                </div>
            </div>
            <div class="quality-card">
                <div class="quality-icon">📈</div>
                <div class="quality-metric">
                    <div class="quality-label">Sample Rate Accuracy</div>
                    <div class="quality-value" id="rate-accuracy">--</div>
                </div>
            </div>
            <div class="quality-card">
                <div class="quality-icon">📦</div>
                <div class="quality-metric">
                    <div class="quality-label">Avg Completeness</div>
                    <div class="quality-value" id="avg-completeness">--</div>
                </div>
            </div>
            <div class="quality-card">
                <div class="quality-icon">🎯</div>
                <div class="quality-metric">
                    <div class="quality-label">Data Continuity</div>
                    <div class="quality-value" id="data-continuity">--</div>
                </div>
            </div>
        </div>
        <div class="quality-details" id="quality-details"></div>
    </div>

    <!-- WWV Timing Validation Section -->
    <div class="wwv-section" id="wwv-section" style="display: none;">
        <h2>⏱️ WWV/CHU Timing Validation</h2>
        <div class="wwv-grid">
            <div class="wwv-card">
                <h3>Tone Detection Rate</h3>
                <div class="value" id="wwv-detection-rate">--</div>
                <div class="subtext" id="wwv-detection-count">0/0 tones detected</div>
            </div>
            <div class="wwv-card">
                <h3>Timing Error (Mean)</h3>
                <div class="value" id="wwv-timing-mean">--</div>
                <div class="subtext">vs UTC ground truth</div>
            </div>
            <div class="wwv-card">
                <h3>Timing Precision (Std)</h3>
                <div class="value" id="wwv-timing-std">--</div>
                <div class="subtext">Jitter / variance</div>
            </div>
            <div class="wwv-card">
                <h3>Max Error</h3>
                <div class="value" id="wwv-timing-max">--</div>
                <div class="subtext">Worst case deviation</div>
            </div>
        </div>
        <div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 13px; color: #666;">
            <strong>Ground Truth Validation:</strong> WWV (Fort Collins) broadcasts a 1000 Hz tone at the start of each UTC minute. This provides independent timing verification beyond RTP timestamps.
        </div>
    </div>

    <!-- Channel Summary Table -->
    <div class="summary-table-container" id="summary-table-container" style="display: none;">
        <h2 style="margin: 0 0 15px 0; font-size: 18px; color: #333;">📡 Channel Summary</h2>
        <table class="summary-table">
            <thead>
                <tr>
                    <th onclick="sortTable(0)">Channel</th>
                    <th onclick="sortTable(1)">Health</th>
                    <th onclick="sortTable(2)">Comp%</th>
                    <th onclick="sortTable(3)">Loss%</th>
                    <th onclick="sortTable(4)">Drift (ms)</th>
                    <th onclick="sortTable(5)">WWV Detect</th>
                    <th onclick="sortTable(6)">WWV Error</th>
                    <th onclick="sortTable(7)">Gaps</th>
                </tr>
            </thead>
            <tbody id="summary-table-body">
                <!-- Populated by JavaScript -->
            </tbody>
        </table>
    </div>

    </div> <!-- end dashboard-panel -->

    <!-- Channels Tab Panel -->
    <div id="channels-panel" class="tab-panel">
        <div id="channels-container" class="channels-grid"></div>
    </div>

    <div id="error-container"></div>
    <div id="loading-container" class="loading">Loading recording statistics...</div>

        <div class="logs-container">
            <div class="logs-header">
                <h3 style="margin: 0;">📋 Daemon Logs</h3>
                <button class="btn-refresh" onclick="loadLogs()">🔄 Refresh Logs</button>
            </div>
            <div class="logs-content" id="logs-content">
                <div class="loading">Loading logs...</div>
            </div>
        </div>
    </div> <!-- end content -->

    <script>
        let refreshInterval;

        async function apiRequest(endpoint, options = {}) {
            const token = localStorage.getItem('authToken');
            
            // If no token, set default and don't make request yet
            if (!token) {
                console.log('No auth token found, setting default');
                localStorage.setItem('authToken', 'admin-token');
                throw new Error('Authentication token not found - please refresh the page');
            }
            
            const url = `/api${endpoint}`;
            const cacheBustUrl = url + (url.includes('?') ? '&' : '?') + '_t=' + Date.now();

            const response = await fetch(cacheBustUrl, {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache',
                    ...options.headers
                },
                cache: 'no-store',
                ...options
            });

            if (response.status === 401) {
                // Show error instead of auto-redirecting
                throw new Error('Authentication failed - please log in via the main configuration page');
            }

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            return await response.json();
        }

        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            document.getElementById(tabName + '-panel').classList.add('active');
        }

        // Sort summary table
        let sortColumn = -1;
        let sortAscending = true;
        
        function sortTable(columnIndex) {
            const table = document.getElementById('summary-table-body');
            const rows = Array.from(table.getElementsByTagName('tr'));
            
            // Toggle sort direction if same column
            if (sortColumn === columnIndex) {
                sortAscending = !sortAscending;
            } else {
                sortColumn = columnIndex;
                sortAscending = true;
            }
            
            rows.sort((a, b) => {
                let aVal = a.cells[columnIndex].textContent.trim();
                let bVal = b.cells[columnIndex].textContent.trim();
                
                // Extract numbers from percentage/numeric strings
                aVal = parseFloat(aVal.replace(/[^0-9.-]/g, '')) || aVal;
                bVal = parseFloat(bVal.replace(/[^0-9.-]/g, '')) || bVal;
                
                if (aVal < bVal) return sortAscending ? -1 : 1;
                if (aVal > bVal) return sortAscending ? 1 : -1;
                return 0;
            });
            
            // Re-append sorted rows
            rows.forEach(row => table.appendChild(row));
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
        }

        function formatNumber(num) {
            return num.toLocaleString();
        }

        function showAuthError(message) {
            document.getElementById('auth-error-message').textContent = message;
            document.getElementById('auth-error').style.display = 'block';
            document.getElementById('loading-container').style.display = 'none';
        }

        function calculateDataQuality(stats) {
            console.log('calculateDataQuality called', stats);
            if (!stats || !stats.recorders || Object.keys(stats.recorders).length === 0) {
                console.log('No recorders data, hiding quality section');
                document.getElementById('quality-section').style.display = 'none';
                return;
            }

            console.log('Showing quality section with', Object.keys(stats.recorders).length, 'recorders');
            document.getElementById('quality-section').style.display = 'block';

            const recorders = Object.values(stats.recorders);
            let totalCompleteness = 0;
            let totalRateAccuracy = 0;
            let issues = [];
            let excellentCount = 0;

            recorders.forEach(rec => {
                totalCompleteness += rec.completeness_pct;
                
                // Calculate rate accuracy (how close to 10.0 samples/sec)
                const rateAccuracy = 100 - Math.abs((rec.samples_per_sec - 10.0) / 10.0 * 100);
                totalRateAccuracy += Math.max(0, rateAccuracy);

                // Track issues
                if (rec.completeness_pct < 95) {
                    issues.push({
                        type: 'error',
                        message: `${rec.channel_name}: Low completeness (${rec.completeness_pct.toFixed(1)}%)`
                    });
                } else if (rec.completeness_pct < 99) {
                    issues.push({
                        type: 'warning',
                        message: `${rec.channel_name}: Moderate completeness (${rec.completeness_pct.toFixed(1)}%)`
                    });
                } else {
                    excellentCount++;
                }

                if (rec.packet_loss_pct > 1) {
                    issues.push({
                        type: 'error',
                        message: `${rec.channel_name}: Packet loss detected (${rec.packet_loss_pct.toFixed(2)}%)`
                    });
                }

                if (Math.abs(rec.samples_per_sec - 10.0) > 0.5) {
                    issues.push({
                        type: 'error',
                        message: `${rec.channel_name}: Sample rate off target (${rec.samples_per_sec.toFixed(1)}/s vs 10.0/s)`
                    });
                }
            });

            const avgCompleteness = totalCompleteness / recorders.length;
            const avgRateAccuracy = totalRateAccuracy / recorders.length;
            const continuity = (excellentCount / recorders.length * 100);

            // Overall quality score (weighted average)
            const qualityScore = (avgCompleteness * 0.5 + avgRateAccuracy * 0.3 + continuity * 0.2);

            // Update quality metrics
            const qualityEl = document.getElementById('quality-score');
            const accuracyEl = document.getElementById('rate-accuracy');
            const completenessEl = document.getElementById('avg-completeness');
            const continuityEl = document.getElementById('data-continuity');

            // Overall quality
            qualityEl.textContent = qualityScore.toFixed(1) + '%';
            qualityEl.className = 'quality-value ' + getQualityClass(qualityScore);

            // Rate accuracy
            accuracyEl.textContent = avgRateAccuracy.toFixed(1) + '%';
            accuracyEl.className = 'quality-value ' + getQualityClass(avgRateAccuracy);

            // Completeness
            completenessEl.textContent = avgCompleteness.toFixed(1) + '%';
            completenessEl.className = 'quality-value ' + getQualityClass(avgCompleteness);

            // Continuity
            continuityEl.textContent = continuity.toFixed(0) + '%';
            continuityEl.className = 'quality-value ' + getQualityClass(continuity);

            // Display issues
            const detailsEl = document.getElementById('quality-details');
            if (issues.length === 0) {
                detailsEl.innerHTML = '<div style="color: #4CAF50; font-weight: 500;">✅ All channels operating normally. Data pipeline validated.</div>';
            } else {
                detailsEl.innerHTML = issues.map(issue => 
                    `<div class="quality-issue ${issue.type}">${issue.type === 'error' ? '🔴' : '⚠️'} ${issue.message}</div>`
                ).join('');
            }
        }

        function getQualityClass(score) {
            if (score >= 99) return 'excellent';
            if (score >= 95) return 'good';
            if (score >= 90) return 'fair';
            return 'poor';
        }

        async function loadRecordingStats() {
            try {
                const stats = await apiRequest('/monitoring/recording-stats');
                
                if (!stats.available) {
                    document.getElementById('loading-container').innerHTML = 
                        '<div class="loading">⚠️ No recording statistics available - daemon may not be running</div>';
                    document.getElementById('health-summary').style.display = 'none';
                    document.getElementById('system-summary').style.display = 'none';
                    return;
                }

                // Hide loading, show content
                document.getElementById('loading-container').style.display = 'none';
                document.getElementById('health-summary').style.display = 'flex';
                document.getElementById('system-summary').style.display = 'grid';
                document.getElementById('error-container').innerHTML = '';

                // Update health summary
                document.getElementById('healthy-count').textContent = stats.healthy_channels;
                document.getElementById('warning-count').textContent = stats.warning_channels;
                document.getElementById('error-count').textContent = stats.error_channels;
                document.getElementById('packet-loss-pct').textContent = stats.aggregate_packet_loss_pct.toFixed(2) + '%';

                // Update system summary
                document.getElementById('recording-duration').textContent = formatDuration(stats.recording_duration_sec);
                document.getElementById('total-data').textContent = stats.total_data_mb.toFixed(1) + ' MB';
                document.getElementById('total-packets').textContent = formatNumber(stats.total_packets_received);
                document.getElementById('channel-count').textContent = stats.channels;

                const packetsPerSec = stats.recording_duration_sec > 0 ? 
                    (stats.total_packets_received / stats.recording_duration_sec).toFixed(1) : 0;
                document.getElementById('packets-per-sec').textContent = packetsPerSec + ' packets/sec';

                // Process WWV timing validation data
                let wwvChannels = [];
                let totalDetections = 0;
                let expectedDetections = 0;
                let timingErrors = [];
                
                for (const [ssrc, rec] of Object.entries(stats.recorders)) {
                    if (rec.timing_validation && rec.timing_validation.enabled) {
                        wwvChannels.push(rec);
                        totalDetections += rec.timing_validation.tone_detections_total;
                        expectedDetections += rec.timing_validation.tone_detections_expected;
                        if (rec.timing_validation.timing_error_mean_ms !== null) {
                            timingErrors.push({
                                mean: rec.timing_validation.timing_error_mean_ms,
                                std: rec.timing_validation.timing_error_std_ms,
                                max: rec.timing_validation.timing_error_max_ms
                            });
                        }
                    }
                }
                
                // Update WWV validation section if we have WWV channels
                if (wwvChannels.length > 0) {
                    document.getElementById('wwv-section').style.display = 'block';
                    
                    const detectionRate = expectedDetections > 0 ? (totalDetections / expectedDetections) : 0;
                    document.getElementById('wwv-detection-rate').textContent = (detectionRate * 100).toFixed(0) + '%';
                    document.getElementById('wwv-detection-count').textContent = `${totalDetections}/${expectedDetections} tones detected`;
                    
                    if (timingErrors.length > 0) {
                        const avgMean = timingErrors.reduce((sum, e) => sum + e.mean, 0) / timingErrors.length;
                        const avgStd = timingErrors.reduce((sum, e) => sum + e.std, 0) / timingErrors.length;
                        const maxError = Math.max(...timingErrors.map(e => e.max));
                        
                        document.getElementById('wwv-timing-mean').textContent = avgMean.toFixed(1) + ' ms';
                        document.getElementById('wwv-timing-std').textContent = '±' + avgStd.toFixed(1) + ' ms';
                        document.getElementById('wwv-timing-max').textContent = maxError.toFixed(1) + ' ms';
                    } else {
                        document.getElementById('wwv-timing-mean').textContent = '--';
                        document.getElementById('wwv-timing-std').textContent = '--';
                        document.getElementById('wwv-timing-max').textContent = '--';
                    }
                } else {
                    document.getElementById('wwv-section').style.display = 'none';
                }
                
                // Populate summary table
                document.getElementById('summary-table-container').style.display = 'block';
                const tableBody = document.getElementById('summary-table-body');
                tableBody.innerHTML = '';
                
                for (const [ssrc, rec] of Object.entries(stats.recorders)) {
                    const row = document.createElement('tr');
                    
                    const healthIcon = rec.health_status === 'healthy' ? '🟢' :
                                      rec.health_status === 'warning' ? '🟡' : '🔴';
                    
                    const completenessClass = rec.completeness_pct >= 99 ? 'metric-good' :
                                             rec.completeness_pct >= 95 ? 'metric-warning' : 'metric-error';
                    const lossClass = rec.packet_loss_pct <= 1 ? 'metric-good' :
                                     rec.packet_loss_pct <= 5 ? 'metric-warning' : 'metric-error';
                    
                    // WWV detection column
                    let wwvDetect = 'N/A';
                    if (rec.timing_validation && rec.timing_validation.enabled) {
                        const rate = rec.timing_validation.detection_rate * 100;
                        const rateClass = rate >= 80 ? 'metric-good' : rate >= 50 ? 'metric-warning' : 'metric-error';
                        wwvDetect = `<span class="${rateClass}">${rec.timing_validation.tone_detections_total}/${rec.timing_validation.tone_detections_expected}</span>`;
                    }
                    
                    // WWV timing error column
                    let wwvError = 'N/A';
                    if (rec.timing_validation && rec.timing_validation.last_timing_error_ms !== null) {
                        const error = Math.abs(rec.timing_validation.last_timing_error_ms);
                        const errorClass = error <= 10 ? 'metric-good' : error <= 50 ? 'metric-warning' : 'metric-error';
                        wwvError = `<span class="${errorClass}">${rec.timing_validation.last_timing_error_ms.toFixed(1)} ms</span>`;
                    }
                    
                    // Discontinuities column
                    let gapsText = '0';
                    if (rec.discontinuities) {
                        const gapClass = rec.discontinuities.gaps === 0 ? 'metric-good' : 
                                        rec.discontinuities.gaps <= 5 ? 'metric-warning' : 'metric-error';
                        gapsText = `<span class="${gapClass}">${rec.discontinuities.gaps}</span>`;
                    }
                    
                    row.innerHTML = `
                        <td class="channel-name">
                            <button class="listen-btn" onclick="toggleAudio('${ssrc}')" id="listen-btn-${ssrc}" 
                                    style="background: none; border: 2px solid transparent; cursor: pointer; font-size: 18px; margin-right: 8px; vertical-align: middle; padding: 4px 8px; border-radius: 4px; transition: all 0.3s ease;" 
                                    title="Listen to channel">
                                🔈
                            </button>
                            ${rec.channel_name}
                        </td>
                        <td>${healthIcon}</td>
                        <td class="${completenessClass}">${rec.completeness_pct.toFixed(1)}%</td>
                        <td class="${lossClass}">${rec.packet_loss_pct.toFixed(2)}%</td>
                        <td>${rec.timing_drift_mean_ms.toFixed(1)}±${rec.timing_drift_std_ms.toFixed(1)}</td>
                        <td>${wwvDetect}</td>
                        <td>${wwvError}</td>
                        <td>${gapsText}</td>
                    `;
                    
                    tableBody.appendChild(row);
                }

                // Render channel cards (for Channels tab)
                const container = document.getElementById('channels-container');
                container.innerHTML = '';

                for (const [ssrc, rec] of Object.entries(stats.recorders)) {
                    // Debug: Log timing data for first channel
                    if (ssrc === Object.keys(stats.recorders)[0]) {
                        console.log('Timing data for', rec.channel_name, ':', {
                            timing_drift_mean_ms: rec.timing_drift_mean_ms,
                            timing_drift_std_ms: rec.timing_drift_std_ms,
                            timing_samples_count: rec.timing_samples_count
                        });
                    }
                    
                    const card = document.createElement('div');
                    card.className = `channel-card ${rec.health_status}`;
                    
                    const indicator = rec.health_status === 'healthy' ? '🟢' :
                                    rec.health_status === 'warning' ? '🟡' : '🔴';
                    
                    const completenessClass = rec.completeness_pct >= 99 ? 'good' :
                                            rec.completeness_pct >= 95 ? 'warning' : 'error';
                    
                    const packetLossClass = rec.packet_loss_pct <= 1 ? 'good' :
                                          rec.packet_loss_pct <= 5 ? 'warning' : 'error';
                    
                    card.innerHTML = `
                        <div class="channel-header">
                            <div>
                                <div class="channel-title">${rec.channel_name}</div>
                                <div class="channel-freq">${rec.frequency_mhz.toFixed(2)} MHz</div>
                            </div>
                            <div class="health-indicator">${indicator}</div>
                        </div>
                        <div class="channel-status">
                            ${rec.is_stale ? '⚠️ No data for ' + rec.data_freshness_sec + 's' : rec.health_message}
                        </div>
                        <div class="metrics-row">
                            <div class="metric">
                                <div class="metric-label">Completeness</div>
                                <div class="metric-value ${completenessClass}">${rec.completeness_pct.toFixed(1)}%</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Packet Loss</div>
                                <div class="metric-value ${packetLossClass}">${rec.packet_loss_pct.toFixed(2)}%</div>
                            </div>
                        </div>
                        <div class="metrics-row">
                            <div class="metric">
                                <div class="metric-label">Samples Received</div>
                                <div class="metric-value">${formatNumber(rec.samples_received)}</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label" title="Actual samples received per second (measures data quality, not configured rate)">Throughput</div>
                                <div class="metric-value">${rec.samples_per_sec.toFixed(1)}/s</div>
                            </div>
                        </div>
                        <div class="metrics-row">
                            <div class="metric">
                                <div class="metric-label">Files Created</div>
                                <div class="metric-value">${rec.file_count}</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Data Written</div>
                                <div class="metric-value">${rec.total_size_mb.toFixed(1)} MB</div>
                            </div>
                        </div>
                        <div class="metrics-row">
                            <div class="metric">
                                <div class="metric-label">Packets</div>
                                <div class="metric-value">${formatNumber(rec.packets_received)}</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Duration</div>
                                <div class="metric-value">${formatDuration(rec.recording_duration_sec)}</div>
                            </div>
                        </div>
                        <div class="metrics-row">
                            <div class="metric">
                                <div class="metric-label">Sync State</div>
                                <div class="metric-value">${rec.sync_state || 'unknown'}</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Timing Drift</div>
                                <div class="metric-value">${rec.timing_drift_mean_ms !== undefined ? rec.timing_drift_mean_ms.toFixed(1) + ' ms' : 'N/A'}</div>
                            </div>
                        </div>
                        <div class="metrics-row">
                            <div class="metric">
                                <div class="metric-label">Timing Variance</div>
                                <div class="metric-value">${rec.timing_drift_std_ms !== undefined ? rec.timing_drift_std_ms.toFixed(1) + ' ms' : 'N/A'}</div>
                            </div>
                            <div class="metric">
                                <div class="metric-label">Timing Samples</div>
                                <div class="metric-value">${rec.timing_samples_count || 0}</div>
                            </div>
                        </div>
                    `;
                    
                    // Add WWV timing validation metrics if available
                    if (rec.timing_validation && rec.timing_validation.enabled) {
                        const detectionRate = (rec.timing_validation.detection_rate * 100).toFixed(0);
                        const rateClass = detectionRate >= 80 ? 'good' : detectionRate >= 50 ? 'warning' : 'error';
                        
                        card.innerHTML += `
                            <div style="border-top: 1px solid #e0e0e0; margin: 15px 0; padding-top: 15px;">
                                <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #667eea;">⏱️ WWV Timing Validation</h4>
                                <div class="metrics-row">
                                    <div class="metric">
                                        <div class="metric-label">Tone Detection</div>
                                        <div class="metric-value ${rateClass}">${rec.timing_validation.tone_detections_total}/${rec.timing_validation.tone_detections_expected} (${detectionRate}%)</div>
                                    </div>
                                    <div class="metric">
                                        <div class="metric-label">Timing Error</div>
                                        <div class="metric-value">${rec.timing_validation.timing_error_mean_ms !== null ? rec.timing_validation.timing_error_mean_ms.toFixed(1) + ' ms' : 'N/A'}</div>
                                    </div>
                                </div>
                                <div class="metrics-row">
                                    <div class="metric">
                                        <div class="metric-label">Error Std Dev</div>
                                        <div class="metric-value">${rec.timing_validation.timing_error_std_ms !== null ? '±' + rec.timing_validation.timing_error_std_ms.toFixed(1) + ' ms' : 'N/A'}</div>
                                    </div>
                                    <div class="metric">
                                        <div class="metric-label">Last Detection</div>
                                        <div class="metric-value" style="font-size: 11px;">${rec.timing_validation.last_detection_time ? new Date(rec.timing_validation.last_detection_time).toLocaleTimeString() : 'Never'}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Add discontinuity tracking metrics if available
                    if (rec.discontinuities && rec.discontinuities.total_count > 0) {
                        const gapClass = rec.discontinuities.gaps === 0 ? 'good' : 
                                        rec.discontinuities.gaps <= 5 ? 'warning' : 'error';
                        
                        card.innerHTML += `
                            <div style="border-top: 1px solid #e0e0e0; margin: 15px 0; padding-top: 15px;">
                                <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #f44336;">⚠️ Data Discontinuities</h4>
                                <div class="metrics-row">
                                    <div class="metric">
                                        <div class="metric-label">Total Events</div>
                                        <div class="metric-value ${gapClass}">${rec.discontinuities.total_count}</div>
                                    </div>
                                    <div class="metric">
                                        <div class="metric-label">Packet Gaps</div>
                                        <div class="metric-value ${gapClass}">${rec.discontinuities.gaps}</div>
                                    </div>
                                </div>
                                <div class="metrics-row">
                                    <div class="metric">
                                        <div class="metric-label">Largest Gap</div>
                                        <div class="metric-value">${rec.discontinuities.largest_gap_samples} samples</div>
                                    </div>
                                    <div class="metric">
                                        <div class="metric-label">Total Gap Time</div>
                                        <div class="metric-value">${rec.discontinuities.total_gap_duration_ms.toFixed(1)} ms</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (rec.discontinuities) {
                        card.innerHTML += `
                            <div style="border-top: 1px solid #e0e0e0; margin: 15px 0; padding-top: 15px; text-align: center; color: #4CAF50; font-weight: 500;">
                                ✅ No discontinuities detected
                            </div>
                        `;
                    }
                    
                    container.appendChild(card);
                }

                // Calculate and display data quality metrics
                calculateDataQuality(stats);

            } catch (error) {
                console.error('Failed to load recording stats:', error);
                
                // Check if it's an auth error
                if (error.message.includes('Authentication')) {
                    showAuthError(error.message);
                } else {
                    document.getElementById('error-container').innerHTML =
                        `<div class="error-message">❌ Failed to load recording statistics: ${error.message}</div>`;
                    document.getElementById('loading-container').style.display = 'none';
                }
            }
        }

        async function checkDaemonStatus() {
            try {
                const data = await apiRequest('/monitoring/daemon-status');
                const statusText = document.getElementById('daemon-status-text');
                
                if (data.running) {
                    statusText.className = 'status running';
                    statusText.textContent = `● Running (PID: ${data.pid})`;
                } else {
                    statusText.className = 'status stopped';
                    statusText.textContent = '● Stopped';
                }
            } catch (error) {
                const statusText = document.getElementById('daemon-status-text');
                statusText.className = 'status stopped';
                statusText.textContent = '● Unknown';
            }
        }

        async function loadLogs() {
            try {
                const data = await apiRequest('/monitoring/logs');
                const container = document.getElementById('logs-content');
                
                if (data.logs && data.logs.length > 0) {
                    container.innerHTML = data.logs.map(log => {
                        let className = 'log-line';
                        if (log.match(/error|failed|exception/i)) {
                            className += ' error';
                        } else if (log.match(/warning|warn/i)) {
                            className += ' warning';
                        }
                        return `<div class="${className}">${log}</div>`;
                    }).join('');
                } else {
                    container.innerHTML = '<div class="loading">No logs available</div>';
                }
            } catch (error) {
                document.getElementById('logs-content').innerHTML = 
                    '<div class="log-line error">Failed to load logs: ' + error.message + '</div>';
            }
        }

        // Audio streaming state
        let currentAudio = null;
        let currentSSRC = null;

        function toggleAudio(ssrc) {
            const btn = document.getElementById(`listen-btn-${ssrc}`);
            
            // If already playing this channel, stop it
            if (currentSSRC === ssrc && currentAudio) {
                if (currentAudio.readyState === 1) { // WebSocket is OPEN
                    currentAudio.send('A:STOP');
                    currentAudio.close();
                }
                currentAudio = null;
                currentSSRC = null;
                btn.textContent = '🔈';
                btn.title = 'Listen to channel';
                return;
            }
            
            // Stop any currently playing audio
            if (currentAudio) {
                if (currentAudio.readyState === 1) { // WebSocket is OPEN
                    currentAudio.send('A:STOP');
                    currentAudio.close();
                }
                currentAudio = null;
                const oldBtn = document.getElementById(`listen-btn-${currentSSRC}`);
                if (oldBtn) {
                    oldBtn.textContent = '🔈';
                    oldBtn.title = 'Listen to channel';
                    oldBtn.style.background = 'none';
                    oldBtn.style.border = '2px solid transparent';
                    oldBtn.style.animation = 'none';
                }
            }
            
            // Start new audio stream using WebSocket (ka9q-web style)
            console.log(`Starting WebSocket audio stream for SSRC ${ssrc}`);
            
            // First request PCM stream from radiod
            fetch(`/api/audio/stream/${ssrc}`)
                .then(response => response.text())
                .then(data => {
                    console.log(`PCM stream info: ${data}`);
                    
                    // Parse the response to get WebSocket URL
                    const lines = data.split('\n');
                    const wsLine = lines.find(line => line.startsWith('WebSocket:'));
                    if (wsLine) {
                        const wsUrl = wsLine.split(': ')[1];
                        console.log(`Connecting to WebSocket: ${wsUrl}`);
                        
                        // Create WebSocket connection
                        const ws = new WebSocket(wsUrl);
                        ws.binaryType = 'arraybuffer';
                        
                        ws.onopen = () => {
                            console.log('WebSocket audio connection opened');
                            btn.textContent = '🔊';
                            btn.title = 'Stop listening';
                            btn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
                            btn.style.border = '2px solid #2e7d32';
                            btn.style.boxShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
                            btn.style.animation = 'pulse 2s ease-in-out infinite';
                            currentSSRC = ssrc;
                            currentAudio = ws;
                            
                            // Send START command (like ka9q-web)
                            ws.send('A:START');
                        };
                        
                        // Create Web Audio context for playback
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: 12000 // Match radiod's PCM output
                        });
                        
                        // Create a buffer to queue audio samples
                        let audioQueue = [];
                        let isPlaying = false;
                        let nextPlayTime = 0;
                        
                        let packetCount = 0;
                        
                        ws.onmessage = (event) => {
                            if (event.data instanceof ArrayBuffer) {
                                // Parse RTP packet and extract PCM audio
                                const rtpPacket = new DataView(event.data);
                                
                                // RTP header is at least 12 bytes
                                if (rtpPacket.byteLength < 12) return;
                                
                                // Debug first few packets
                                if (packetCount < 3) {
                                    console.log(`RTP packet ${packetCount}: size=${rtpPacket.byteLength}, first bytes:`, 
                                        Array.from(new Uint8Array(event.data, 0, Math.min(32, rtpPacket.byteLength)))
                                            .map(b => b.toString(16).padStart(2, '0')).join(' '));
                                    packetCount++;
                                }
                                
                                // Parse RTP header (matching our Python audio_streamer.py)
                                const headerByte0 = rtpPacket.getUint8(0);
                                const csrcCount = headerByte0 & 0x0F;
                                const hasExtension = (headerByte0 & 0x10) !== 0;
                                
                                // Start after fixed 12-byte header + CSRC list
                                let payloadOffset = 12 + (csrcCount * 4);
                                
                                // Handle extension header if present (ka9q-radio uses this)
                                if (hasExtension && rtpPacket.byteLength >= payloadOffset + 4) {
                                    const extLengthWords = rtpPacket.getUint16(payloadOffset + 2, false); // Big-endian
                                    payloadOffset += 4 + (extLengthWords * 4);
                                }
                                
                                if (payloadOffset >= rtpPacket.byteLength) {
                                    return; // No payload
                                }
                                
                                // Extract PCM payload (16-bit signed samples, big-endian like IQ data)
                                const payloadLength = rtpPacket.byteLength - payloadOffset;
                                const sampleCount = Math.floor(payloadLength / 2); // 16-bit samples
                                
                                if (packetCount < 3) {
                                    console.log(`  Payload offset: ${payloadOffset}, length: ${payloadLength}, samples: ${sampleCount}`);
                                }
                                
                                // Convert to Float32Array for Web Audio API
                                // ka9q-radio sends PCM as big-endian 16-bit samples
                                const pcmSamples = new Float32Array(sampleCount);
                                for (let i = 0; i < sampleCount; i++) {
                                    const sample = rtpPacket.getInt16(payloadOffset + (i * 2), false); // Big-endian
                                    pcmSamples[i] = sample / 32768.0; // Convert to -1.0 to 1.0 range
                                }
                                
                                // Add samples to queue
                                audioQueue.push(pcmSamples);
                                
                                // Start playback if not already playing
                                if (!isPlaying) {
                                    isPlaying = true;
                                    playAudioQueue();
                                }
                                
                                function playAudioQueue() {
                                    if (audioQueue.length === 0) {
                                        isPlaying = false;
                                        return;
                                    }
                                    
                                    const samples = audioQueue.shift();
                                    
                                    // Create audio buffer
                                    const buffer = audioContext.createBuffer(1, samples.length, audioContext.sampleRate);
                                    buffer.getChannelData(0).set(samples);
                                    
                                    // Create source and connect to destination
                                    const source = audioContext.createBufferSource();
                                    source.buffer = buffer;
                                    source.connect(audioContext.destination);
                                    
                                    // Schedule playback at precise time
                                    const currentTime = audioContext.currentTime;
                                    if (nextPlayTime < currentTime) {
                                        nextPlayTime = currentTime;
                                    }
                                    source.start(nextPlayTime);
                                    
                                    // Update next play time
                                    const duration = samples.length / audioContext.sampleRate;
                                    nextPlayTime += duration;
                                    
                                    // Continue playback
                                    if (audioQueue.length > 0) {
                                        playAudioQueue();
                                    } else {
                                        // Wait a bit for more packets
                                        setTimeout(() => {
                                            if (audioQueue.length > 0) {
                                                playAudioQueue();
                                            } else {
                                                isPlaying = false;
                                            }
                                        }, 50);
                                    }
                                }
                            }
                        };
                        
                        ws.onerror = (error) => {
                            console.error('WebSocket audio error:', error);
                            btn.textContent = '🔈';
                            btn.style.background = 'none';
                            btn.style.border = '2px solid transparent';
                            btn.style.boxShadow = 'none';
                            btn.style.animation = 'none';
                            btn.title = 'Listen to channel';
                            currentAudio = null;
                            currentSSRC = null;
                            alert('Failed to start audio stream. Check console for details.');
                        };
                        
                        ws.onclose = () => {
                            console.log('WebSocket audio connection closed');
                            btn.textContent = '🔈';
                            btn.style.background = 'none';
                            btn.style.border = '2px solid transparent';
                            btn.style.boxShadow = 'none';
                            btn.style.animation = 'none';
                            btn.title = 'Listen to channel';
                            currentAudio = null;
                            currentSSRC = null;
                        };
                    }
                })
                .catch(error => {
                    console.error('Failed to request PCM stream:', error);
                    alert('Failed to start audio stream. Check console for details.');
                });
        }

        function refreshAll() {
            checkDaemonStatus();
            loadRecordingStats();
            loadLogs();
        }

        // Auto-refresh every 30 seconds
        setInterval(refreshAll, 30000);

        // Initial load
        document.addEventListener('DOMContentLoaded', function() {
            // Ensure auth token is set before making any requests
            let token = localStorage.getItem('authToken');
            if (!token) {
                console.log('Setting default auth token');
                localStorage.setItem('authToken', 'admin-token');
                token = 'admin-token';
            }
            
            console.log('Monitoring page loaded, auth token:', token ? 'present' : 'missing');
            
            // Small delay to ensure token is committed to localStorage
            setTimeout(() => {
                refreshAll();
            }, 100);
        });
    </script>
</body>
</html>
