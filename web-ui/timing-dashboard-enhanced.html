<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timing Analysis Dashboard - GRAPE Signal Recorder</title>
    <link rel="stylesheet" href="/styles.css">
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script>
        window.GRAPE_CURRENT_PAGE = 'timing';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0e27;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .header {
            background: linear-gradient(135deg, #1e3a8a 0%, #312e81 100%);
            padding: 20px 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .header h1 {
            color: #fff;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }
        
        .live-dot {
            width: 10px;
            height: 10px;
            background: #10b981;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Alert Banner */
        .alert-banner {
            background: #dc2626;
            color: #fff;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 15px;
        }
        
        .alert-banner.visible {
            display: flex;
        }
        
        .alert-banner.warning {
            background: #f59e0b;
        }
        
        .alert-icon {
            font-size: 24px;
        }
        
        .alert-content {
            flex: 1;
        }
        
        .alert-title {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 4px;
        }
        
        .alert-message {
            font-size: 14px;
            opacity: 0.9;
        }
        
        /* Primary Reference Hero Section */
        .primary-reference {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 20px;
            border-left: 5px solid #10b981;
        }
        
        .primary-reference.ntp {
            border-left-color: #3b82f6;
        }
        
        .primary-reference.degraded {
            border-left-color: #f59e0b;
        }
        
        .primary-reference.poor {
            border-left-color: #ef4444;
        }
        
        .ref-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .ref-title {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
        }
        
        .quality-badge {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            text-transform: uppercase;
        }
        
        .quality-badge.tone-locked {
            background: #10b981;
            color: #fff;
        }
        
        .quality-badge.ntp-synced {
            background: #3b82f6;
            color: #fff;
        }
        
        .quality-badge.interpolated,
        .quality-badge.tone-aged {
            background: #f59e0b;
            color: #fff;
        }
        
        .quality-badge.tone-stable {
            background: #22c55e;  /* Green - tone-based with excellent drift */
            color: #fff;
        }
        
        .quality-badge.wall-clock {
            background: #ef4444;
            color: #fff;
        }
        
        .ref-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .ref-metric {
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 8px;
        }
        
        .ref-metric-label {
            font-size: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .ref-metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .ref-metric-sub {
            font-size: 13px;
            color: #cbd5e1;
        }
        
        .ref-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }
        
        .ref-detail-item {
            display: flex;
            gap: 10px;
            font-size: 13px;
        }
        
        .ref-detail-label {
            color: #94a3b8;
            min-width: 100px;
        }
        
        .ref-detail-value {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
        }
        
        /* Health Cards Grid */
        .health-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .health-card {
            background: #1e293b;
            border-radius: 10px;
            padding: 25px;
            border-left: 4px solid #3b82f6;
        }
        
        .health-card-title {
            font-size: 14px;
            color: #94a3b8;
            text-transform: uppercase;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .health-card-value {
            font-size: 36px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .health-card-percent {
            font-size: 18px;
            color: #cbd5e1;
            margin-bottom: 15px;
        }
        
        .health-card-quality {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 12px;
        }
        
        .health-card-quality.excellent {
            background: #10b981;
            color: #fff;
        }
        
        .health-card-quality.good {
            background: #3b82f6;
            color: #fff;
        }
        
        .health-card-quality.fair {
            background: #f59e0b;
            color: #fff;
        }
        
        .health-card-quality.poor {
            background: #ef4444;
            color: #fff;
        }
        
        .health-card-quality.collecting {
            background: rgba(148, 163, 184, 0.3);
            color: #94a3b8;
            font-style: italic;
        }
        
        .health-card-details {
            font-size: 13px;
            color: #cbd5e1;
            line-height: 1.6;
        }
        
        .health-card-details div {
            margin-bottom: 4px;
        }
        
        .channel-list {
            margin-top: 10px;
        }
        
        .channel-item {
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .status-dot.tone {
            background: #10b981;
        }
        
        .status-dot.ntp {
            background: #3b82f6;
        }
        
        .status-dot.wall {
            background: #ef4444;
        }
        
        /* Charts */
        .chart-section {
            background: #1e293b;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .chart-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #fff;
        }
        
        .chart-container {
            width: 100%;
            height: 400px;
            background: #0f172a;
            border-radius: 8px;
        }
        
        /* Per-Channel Table */
        .channel-table-container {
            background: #1e293b;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        thead {
            background: #0f172a;
        }
        
        th {
            padding: 12px;
            text-align: left;
            font-size: 11px;
            color: #94a3b8;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        td {
            padding: 12px;
            border-top: 1px solid #334155;
            font-size: 14px;
        }
        
        tr:hover {
            background: rgba(255, 255, 255, 0.02);
        }
        
        .health-score {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 13px;
        }
        
        .health-score.excellent {
            background: #10b981;
            color: #fff;
        }
        
        .health-score.good {
            background: #3b82f6;
            color: #fff;
        }
        
        .health-score.fair {
            background: #f59e0b;
            color: #fff;
        }
        
        .health-score.poor {
            background: #ef4444;
            color: #fff;
        }
        
        /* Transitions Log */
        .transitions-section {
            background: #1e293b;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .transition-item {
            background: rgba(255, 255, 255, 0.03);
            border-left: 3px solid #3b82f6;
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 6px;
        }
        
        .transition-time {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 6px;
        }
        
        .transition-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
        }
        
        .transition-details {
            font-size: 13px;
            color: #cbd5e1;
            line-height: 1.6;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #94a3b8;
            font-size: 16px;
        }
        
        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            color: #fca5a5;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .refresh-countdown {
            display: inline-block;
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
        }
        
        /* Propagation Mode Section */
        .propagation-section {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid #334155;
        }
        
        .section-header {
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            display: block;
        }
        
        .section-subtitle {
            font-size: 13px;
            color: #94a3b8;
        }
        
        .prop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }
        
        .prop-station {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 15px;
        }
        
        .prop-station-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #334155;
        }
        
        .prop-station-name {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
        }
        
        .prop-station-distance {
            font-size: 12px;
            color: #94a3b8;
        }
        
        .prop-table {
            width: 100%;
            font-size: 13px;
        }
        
        .prop-table th {
            padding: 8px;
            text-align: left;
            font-size: 10px;
            text-transform: uppercase;
            color: #64748b;
            font-weight: 600;
        }
        
        .prop-table td {
            padding: 8px;
            border-top: 1px solid #1e293b;
        }
        
        .mode-badge {
            display: inline-block;
            background: #3b82f6;
            color: #fff;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .mode-badge.primary {
            background: #10b981;
        }
        
        .alt-mode {
            opacity: 0.7;
            font-size: 0.9em;
        }
        
        .alt-mode td {
            padding-top: 2px !important;
            padding-bottom: 2px !important;
        }
        
        .freq-cell {
            vertical-align: middle;
            font-weight: 600;
        }
        
        .primary-mode {
            border-top: 1px solid #334155;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Unified Navigation -->
        <div id="grape-navigation"></div>

        <div class="header">
        <h1>‚è±Ô∏è Timing Analysis Dashboard</h1>
        <div class="live-indicator">
            <span class="live-dot"></span>
            <span>Live Monitoring</span>
            <span class="refresh-countdown" id="countdown-timer">Next update in 30s</span>
        </div>
    </div>

    <!-- Alert Banner -->
    <div class="alert-banner" id="alert-banner">
        <span class="alert-icon">‚ö†Ô∏è</span>
        <div class="alert-content">
            <div class="alert-title" id="alert-title">Critical Timing Issue</div>
            <div class="alert-message" id="alert-message">Loading...</div>
        </div>
    </div>

    <div id="dashboard-content">
        <div class="loading">‚è≥ Loading timing analysis data...</div>
    </div>

    <script>
        let refreshCountdown = 30;
        let countdownInterval = null;
        let autoRefreshInterval = null;
        
        function startCountdown() {
            refreshCountdown = 30;
            if (countdownInterval) clearInterval(countdownInterval);
            
            countdownInterval = setInterval(() => {
                refreshCountdown--;
                const timer = document.getElementById('countdown-timer');
                if (timer) {
                    timer.textContent = `Next update in ${refreshCountdown}s`;
                }
                if (refreshCountdown <= 0) {
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }
        
        function startAutoRefresh() {
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);
            
            autoRefreshInterval = setInterval(async () => {
                await loadDashboard();
            }, 30000); // Refresh every 30 seconds
        }
        
        async function loadDashboard() {
            try {
                // Load all data in parallel
                const [primaryRef, healthSummary, transitions, propagation, transmission, globalTiming] = await Promise.all([
                    fetch('/api/v1/timing/primary-reference').then(r => r.json()),
                    fetch('/api/v1/timing/health-summary').then(r => r.json()),
                    fetch('/api/v1/timing/transitions?hours=24').then(r => r.json()),
                    fetch('/api/v1/timing/propagation').then(r => r.json()).catch(() => ({ channels: [] })),
                    fetch('/api/v1/timing/transmission?hours=1').then(r => r.json()).catch(() => ({ results: [] })),
                    fetch('/api/v1/timing/global').then(r => r.json()).catch(() => ({ available: false }))
                ]);
                
                renderDashboard(primaryRef, healthSummary, transitions, propagation, transmission, globalTiming);
                checkAlerts(primaryRef, healthSummary);
                startCountdown();
                
            } catch (error) {
                console.error('Error loading dashboard:', error);
                document.getElementById('dashboard-content').innerHTML = `
                    <div class="error">
                        ‚ùå Failed to load timing data: ${error.message}
                        <br><br>
                        Please ensure analytics service is running and generating timing metrics.
                    </div>
                `;
            }
        }
        
        function renderDashboard(primaryRef, healthSummary, transitions, propagation, transmission, globalTiming) {
            const container = document.getElementById('dashboard-content');
            
            // Extract channel names for chart dropdowns, sorted by frequency
            if (healthSummary.channels && healthSummary.channels.length > 0) {
                availableChannels = window.GRAPE_UTILS.sortChannelsByFrequency(
                    healthSummary.channels.map(ch => ch.channel)
                );
            }
            
            container.innerHTML = `
                ${renderPrimaryReference(primaryRef)}
                ${renderGlobalTiming(globalTiming)}
                ${renderTransmissionTime(transmission)}
                ${renderPropagationModes(propagation)}
                ${renderHealthCards(healthSummary)}
                ${renderChannelTable(healthSummary)}
                ${renderChartPlaceholders()}
                ${renderTransitions(transitions)}
            `;
            
            // Load charts after DOM is ready
            setTimeout(() => {
                loadCharts();
            }, 100);
        }
        
        function renderPrimaryReference(data) {
            if (!data.available) {
                return `
                    <div class="primary-reference poor">
                        <div class="ref-header">
                            <div class="ref-title">üéØ Primary Time Reference</div>
                            <span class="quality-badge wall-clock">No Reference</span>
                        </div>
                        <div style="color: #fca5a5; font-size: 14px;">
                            No time reference available. Check core recorder status.
                        </div>
                    </div>
                `;
            }
            
            // Use effective_quality for display if available, fall back to quality
            const displayQuality = data.effective_quality || data.quality;
            const qualityClass = displayQuality.toLowerCase().replace('_', '-');
            const borderClass = displayQuality === 'TONE_LOCKED' || displayQuality === 'TONE_STABLE' ? '' :
                               displayQuality === 'NTP_SYNCED' ? 'ntp' :
                               displayQuality === 'TONE_AGED' || displayQuality === 'INTERPOLATED' ? 'degraded' : 'poor';
            
            return `
                <div class="primary-reference ${borderClass}">
                    <div class="ref-header">
                        <div class="ref-title">üéØ Primary Time Reference</div>
                        <span class="quality-badge ${qualityClass}">${data.quality}</span>
                    </div>
                    
                    <div class="ref-grid">
                        <div class="ref-metric">
                            <div class="ref-metric-label">Source</div>
                            <div class="ref-metric-value">${data.source_channel}</div>
                            <div class="ref-metric-sub">Station: ${data.station}</div>
                        </div>
                        
                        <div class="ref-metric">
                            <div class="ref-metric-label">Precision</div>
                            <div class="ref-metric-value">
                                ${data.precision_ms < 10 ? 
                                  `¬±${data.precision_ms} ms` : 
                                  data.precision_ms < 100 ? 
                                  `¬±${data.precision_ms} ms` :
                                  `¬±${(data.precision_ms/1000).toFixed(1)} sec`}
                            </div>
                            <div class="ref-metric-sub">
                                ${data.snr_db ? `SNR: ${data.snr_db.toFixed(1)} dB | ` : ''}
                                Conf: ${(data.confidence * 100).toFixed(0)}%
                            </div>
                        </div>
                        
                        <div class="ref-metric">
                            <div class="ref-metric-label">Age</div>
                            <div class="ref-metric-value">${formatAge(data.age_seconds)}</div>
                            <div class="ref-metric-sub">Next check: ${formatAge(data.next_check_seconds)}</div>
                        </div>
                        
                        <div class="ref-metric">
                            <div class="ref-metric-label">Base Reference</div>
                            <div class="ref-metric-value">
                                ${data.base_reference || (data.tone_frequency_hz ? `${data.tone_frequency_hz} Hz tone` : 'No Tone')}
                            </div>
                            <div class="ref-metric-sub">
                                ${data.precision_description || (
                                  data.is_tone_based ? 'Tone-derived timing' :
                                  data.quality === 'NTP_SYNCED' ? 'NTP synchronized' :
                                  'Unsynchronized clock'
                                )}
                            </div>
                        </div>
                    </div>
                    
                    <div class="ref-details">
                        <div class="ref-detail-item">
                            <span class="ref-detail-label">RTP Anchor:</span>
                            <span class="ref-detail-value">${data.rtp_anchor.toLocaleString()}</span>
                        </div>
                        <div class="ref-detail-item">
                            <span class="ref-detail-label">UTC Anchor:</span>
                            <span class="ref-detail-value">${data.utc_anchor_iso}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function renderGlobalTiming(data) {
            if (!data || !data.available || !data.latest) {
                return `
                    <div class="propagation-section" style="margin-bottom: 20px; border: 2px dashed #334155;">
                        <div class="section-header">
                            <h2 class="section-title">üåê Global Differential Timing</h2>
                            <div class="section-subtitle">Cross-Channel Clock Error Estimation - Waiting for data</div>
                        </div>
                        <div style="color: #94a3b8; padding: 20px; text-align: center;">
                            Global timing requires detections from multiple channels simultaneously.<br>
                            Using differential measurements eliminates clock error contamination.
                        </div>
                    </div>
                `;
            }
            
            const g = data.latest;
            const gradeColors = { 'A': '#22c55e', 'B': '#84cc16', 'C': '#eab308', 'D': '#ef4444' };
            const gradeColor = gradeColors[g.quality_grade] || '#94a3b8';
            const verifiedIcon = g.verified ? '‚úì Verified' : '‚óã Unverified';
            const clockStr = `${g.clock_error_ms >= 0 ? '+' : ''}${g.clock_error_ms.toFixed(3)} ms`;
            const uncertStr = `¬±${g.uncertainty_ms.toFixed(3)} ms`;
            
            // Mode assignments table
            const modeRows = (g.mode_assignments || []).map(m => `
                <tr>
                    <td style="font-weight: 600;">${m.station}</td>
                    <td>${m.frequency_mhz} MHz</td>
                    <td><span class="mode-badge">${m.mode}</span></td>
                    <td>${m.n_hops}-hop</td>
                    <td>${m.delay_ms.toFixed(2)} ms</td>
                    <td style="color: #94a3b8;">${m.timing_ms.toFixed(2)} ms</td>
                </tr>
            `).join('');
            
            return `
                <div class="propagation-section" style="margin-bottom: 20px; border: 2px solid ${gradeColor};">
                    <div class="section-header">
                        <h2 class="section-title">üåê Global Differential Timing</h2>
                        <div class="section-subtitle">Cross-Channel Clock Error Estimation - ${g.n_channels} channels, ${g.n_pairs} pairs</div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(59, 130, 246, 0.2) 100%); 
                                border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px;">
                            <div>
                                <div style="font-size: 12px; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">
                                    Host Clock Error (vs UTC)
                                </div>
                                <div style="font-size: 32px; font-weight: 700; color: ${gradeColor}; font-family: monospace;">
                                    ${clockStr} ${uncertStr}
                                </div>
                            </div>
                            <div style="display: flex; gap: 24px; text-align: center;">
                                <div>
                                    <div style="font-size: 28px; font-weight: 600; color: ${gradeColor};">${g.quality_grade}</div>
                                    <div style="font-size: 11px; color: #94a3b8;">Grade</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: 600;">${g.n_channels}</div>
                                    <div style="font-size: 11px; color: #94a3b8;">Channels</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: 600;">${(g.confidence * 100).toFixed(0)}%</div>
                                    <div style="font-size: 11px; color: #94a3b8;">Confidence</div>
                                </div>
                                <div>
                                    <div style="font-size: 28px; font-weight: 600;">${g.pair_consistency_ms.toFixed(2)}</div>
                                    <div style="font-size: 11px; color: #94a3b8;">Consistency (ms)</div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 8px; font-size: 12px; color: #94a3b8;">
                            ${verifiedIcon} | 
                            Minute: ${new Date(g.minute_utc).toLocaleTimeString()} |
                            Updated: ${new Date(g.last_updated).toLocaleTimeString()}
                        </div>
                    </div>
                    
                    <div style="margin-top: 16px;">
                        <div style="font-size: 14px; font-weight: 600; color: #fff; margin-bottom: 8px;">Mode Assignments</div>
                        <table class="prop-table">
                            <thead>
                                <tr>
                                    <th>Station</th>
                                    <th>Frequency</th>
                                    <th>Mode</th>
                                    <th>Hops</th>
                                    <th>Delay</th>
                                    <th>Observed</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${modeRows || '<tr><td colspan="6" style="color:#64748b">No mode data</td></tr>'}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
        
        function renderTransmissionTime(data) {
            if (!data.results || data.results.length === 0) {
                return `
                    <div class="propagation-section" style="margin-bottom: 20px;">
                        <div class="section-header">
                            <h2 class="section-title">üéØ UTC(NIST) Back-Calculation</h2>
                            <div class="section-subtitle">Virtual Atomic Clock - Awaiting Data</div>
                        </div>
                        <div style="color: #94a3b8; padding: 20px; text-align: center;">
                            No transmission time data yet. Requires good WWV/WWVH/CHU signal detection.
                        </div>
                    </div>
                `;
            }
            
            // Combined estimate banner
            let combinedBanner = '';
            if (data.combined) {
                const c = data.combined;
                const gradeColors = { 'A': '#22c55e', 'B': '#84cc16', 'C': '#eab308', 'D': '#ef4444' };
                const gradeColor = gradeColors[c.quality_grade] || '#94a3b8';
                const verifiedIcon = c.verified ? '‚úì' : '‚óã';
                const offsetStr = `${c.utc_offset_ms >= 0 ? '+' : ''}${c.utc_offset_ms.toFixed(3)} ms`;
                const uncertStr = `¬±${c.uncertainty_ms.toFixed(3)} ms`;
                
                combinedBanner = `
                    <div style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%); 
                                border: 1px solid ${gradeColor}; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px;">
                            <div>
                                <div style="font-size: 12px; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px;">
                                    Combined UTC(NIST) Estimate
                                </div>
                                <div style="font-size: 28px; font-weight: 700; color: ${gradeColor}; font-family: monospace;">
                                    ${offsetStr} ${uncertStr}
                                </div>
                            </div>
                            <div style="display: flex; gap: 24px; text-align: center;">
                                <div>
                                    <div style="font-size: 24px; font-weight: 600; color: ${gradeColor};">${c.quality_grade}</div>
                                    <div style="font-size: 11px; color: #94a3b8;">Grade</div>
                                </div>
                                <div>
                                    <div style="font-size: 24px; font-weight: 600;">${c.n_stations}</div>
                                    <div style="font-size: 11px; color: #94a3b8;">Stations</div>
                                </div>
                                <div>
                                    <div style="font-size: 24px; font-weight: 600;">${c.n_measurements}</div>
                                    <div style="font-size: 11px; color: #94a3b8;">Measurements</div>
                                </div>
                                <div>
                                    <div style="font-size: 24px; font-weight: 600;">${(c.consistency * 100).toFixed(0)}%</div>
                                    <div style="font-size: 11px; color: #94a3b8;">Consistency</div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 8px; font-size: 12px; color: #94a3b8;">
                            Stations: ${c.stations.join(', ')} | 
                            ${c.verified ? '‚úì Verified' : '‚óã Unverified'} |
                            Last 5 minutes
                        </div>
                    </div>
                `;
            }
            
            // Get latest result per channel
            const latestByChannel = {};
            for (const r of data.results) {
                if (!latestByChannel[r.channel] || new Date(r.timestamp) > new Date(latestByChannel[r.channel].timestamp)) {
                    latestByChannel[r.channel] = r;
                }
            }
            
            const rows = Object.values(latestByChannel).map(r => {
                const hasOffset = r.utc_nist_offset_ms !== null && r.confidence > 0.3;
                const verifiedIcon = hasOffset ? (r.utc_nist_verified ? '‚úì' : '‚óã') : '';
                const verifiedClass = r.utc_nist_verified ? 'color: #22c55e;' : 'color: #94a3b8;';
                const confColor = r.confidence > 0.7 ? '#22c55e' : r.confidence > 0.5 ? '#eab308' : r.confidence > 0.3 ? '#f97316' : '#94a3b8';
                const offsetDisplay = hasOffset 
                    ? `${r.utc_nist_offset_ms >= 0 ? '+' : ''}${r.utc_nist_offset_ms.toFixed(2)} ms` 
                    : '<span style="color: #64748b; font-style: italic;">mode only</span>';
                
                return `
                    <tr>
                        <td style="font-weight: 600;">${r.frequency_mhz} MHz</td>
                        <td>${r.station}</td>
                        <td>${r.mode}</td>
                        <td>${r.n_hops}</td>
                        <td>${r.propagation_delay_ms.toFixed(2)} ms</td>
                        <td style="${verifiedClass} font-weight: 600;">${offsetDisplay} ${verifiedIcon}</td>
                        <td><span style="color: ${confColor};">${(r.confidence * 100).toFixed(0)}%</span></td>
                        <td style="color: #94a3b8; font-size: 11px;">${new Date(r.timestamp).toLocaleTimeString()}</td>
                    </tr>
                `;
            }).join('');
            
            return `
                <div class="propagation-section" style="margin-bottom: 20px;">
                    <div class="section-header">
                        <h2 class="section-title">üéØ UTC(NIST) Back-Calculation</h2>
                        <div class="section-subtitle">Virtual Atomic Clock - ${data.count} measurements from ${new Set(data.results.map(r => r.station)).size} stations</div>
                    </div>
                    
                    ${combinedBanner}
                    
                    <div style="font-size: 13px; color: #94a3b8; margin-bottom: 8px;">Individual Channel Measurements:</div>
                    <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <thead>
                            <tr style="background: rgba(255,255,255,0.05); text-align: left;">
                                <th style="padding: 10px;">Freq</th>
                                <th style="padding: 10px;">Station</th>
                                <th style="padding: 10px;">Mode</th>
                                <th style="padding: 10px;">Hops</th>
                                <th style="padding: 10px;">Prop Delay</th>
                                <th style="padding: 10px;">UTC(NIST) Offset</th>
                                <th style="padding: 10px;">Confidence</th>
                                <th style="padding: 10px;">Last Update</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>
                </div>
            `;
        }
        
        function renderPropagationModes(data) {
            if (!data.channels || data.channels.length === 0) {
                return '';  // No propagation data available
            }
            
            // Group by station
            const wwvChannels = data.channels.filter(ch => ch.station === 'WWV');
            const chuChannels = data.channels.filter(ch => ch.station === 'CHU');
            
            // Build WWVH data from wwvh_alternate in WWV channels (shared freqs: 2.5, 5, 10, 15 MHz)
            const wwvhChannels = data.channels
                .filter(ch => ch.wwvh_alternate)
                .map(ch => ({
                    ...ch.wwvh_alternate,
                    frequency_mhz: ch.frequency_mhz,
                    receiver_grid: ch.receiver_grid,
                    current_snr_db: ch.current_snr_db  // Same SNR - discrimination determines source
                }));
            
            function renderStationSection(station, channels, color, subtitle = '') {
                if (channels.length === 0) return '';
                
                const firstChannel = channels[0];
                const distance = firstChannel.distance_km;
                const grid = firstChannel.receiver_grid || 'Unknown';
                
                // Show all propagation modes per frequency, grouped by frequency
                const modeRows = channels.map(ch => {
                    const modes = ch.propagation_modes || [ch.primary_mode].filter(Boolean);
                    if (!modes || modes.length === 0) return '';
                    
                    // First row shows frequency and SNR, spans multiple modes
                    const rowCount = modes.length;
                    return modes.map((mode, idx) => {
                        const isPrimary = idx === 0;
                        const freqCell = idx === 0 
                            ? `<td rowspan="${rowCount}" class="freq-cell">${ch.frequency_mhz} MHz</td>` 
                            : '';
                        const snrCell = idx === 0 
                            ? `<td rowspan="${rowCount}">${ch.current_snr_db ? ch.current_snr_db + ' dB' : '‚Äî'}</td>` 
                            : '';
                        const rowClass = isPrimary ? 'primary-mode' : 'alt-mode';
                        return `
                            <tr class="${rowClass}">
                                ${freqCell}
                                <td><span class="mode-badge ${isPrimary ? 'primary' : ''}">${mode.mode}</span></td>
                                <td>${mode.delay_ms.toFixed(2)} ms</td>
                                <td>¬±${mode.uncertainty_ms.toFixed(2)} ms</td>
                                <td>${mode.elevation_deg.toFixed(1)}¬∞</td>
                                ${snrCell}
                            </tr>
                        `;
                    }).join('');
                }).join('');
                
                return `
                    <div class="prop-station" style="border-left: 4px solid ${color};">
                        <div class="prop-station-header">
                            <span class="prop-station-name">${station}</span>
                            <span class="prop-station-distance">${distance} km from ${grid}${subtitle}</span>
                        </div>
                        <table class="prop-table">
                            <thead>
                                <tr>
                                    <th>Frequency</th>
                                    <th>Mode</th>
                                    <th>Delay</th>
                                    <th>Uncertainty</th>
                                    <th>Elevation</th>
                                    <th>SNR</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${modeRows}
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            return `
                <div class="propagation-section">
                    <div class="section-header">
                        <span class="section-title">üì° Propagation Mode Analysis</span>
                        <span class="section-subtitle">Expected ionospheric delays for HF time transfer</span>
                    </div>
                    <div class="prop-grid">
                        ${renderStationSection('WWV', wwvChannels, '#10b981', ' (Colorado)')}
                        ${renderStationSection('WWVH', wwvhChannels, '#3b82f6', ' (Hawaii)')}
                        ${renderStationSection('CHU', chuChannels, '#f59e0b', ' (Canada)')}
                    </div>
                </div>
            `;
        }
        
        function renderHealthCards(data) {
            const toneLockPct = parseFloat(data.tone_lock_percentage);
            const driftQuality = data.drift.quality;
            const jitterQuality = data.jitter.quality;
            const stabilityQuality = data.transitions.stability;
            
            // Build channel list for tone-locked
            const toneChannels = data.channels
                .filter(ch => ch.quality === 'TONE_LOCKED')
                .map(ch => `
                    <div class="channel-item">
                        <span class="status-dot tone"></span>
                        ${ch.channel}
                    </div>
                `).join('');
            
            const ntpChannels = data.channels
                .filter(ch => ch.quality === 'NTP_SYNCED')
                .map(ch => `
                    <div class="channel-item">
                        <span class="status-dot ntp"></span>
                        ${ch.channel}
                    </div>
                `).join('');
            
            return `
                <div class="health-cards">
                    <div class="health-card">
                        <div class="health-card-title">Tone-Locked Channels</div>
                        <div class="health-card-value">${data.tone_locked_channels}/${data.total_channels}</div>
                        <div class="health-card-percent">${toneLockPct.toFixed(0)}%</div>
                        <div class="channel-list">
                            ${toneChannels}
                            ${ntpChannels}
                        </div>
                    </div>
                    
                    <div class="health-card">
                        <div class="health-card-title">RTP Drift (Average)</div>
                        <div class="health-card-value">¬±${data.drift.average_ms} ms</div>
                        <div class="health-card-quality ${driftQuality}">${driftQuality}</div>
                        <div class="health-card-details">
                            <div>Range: ${data.drift.range_ms} ms</div>
                            <div>Max: ${data.drift.max_ms} ms</div>
                            <div>Trend: Stable</div>
                        </div>
                    </div>
                    
                    <div class="health-card">
                        <div class="health-card-title">Jitter (Stability)</div>
                        <div class="health-card-value">
                            ${parseFloat(data.jitter.average_ms) > 1000 ? 
                              'Stabilizing...' : 
                              `¬±${data.jitter.average_ms} ms`}
                        </div>
                        <div class="health-card-quality ${parseFloat(data.jitter.average_ms) > 1000 ? 'collecting' : jitterQuality}">
                            ${parseFloat(data.jitter.average_ms) > 1000 ? 
                              'collecting data' : 
                              jitterQuality}
                        </div>
                        <div class="health-card-details">
                            <div>Lower is better</div>
                            <div>Target: < 0.5 ms</div>
                            ${parseFloat(data.jitter.average_ms) > 1000 ? 
                              '<div style="color: #94a3b8; font-size: 12px; margin-top: 8px;">Waiting for more timing data...</div>' : ''}
                        </div>
                    </div>
                    
                    <div class="health-card">
                        <div class="health-card-title">Transitions (24h)</div>
                        <div class="health-card-value">${data.transitions.last_24h}</div>
                        <div class="health-card-quality ${stabilityQuality}">${stabilityQuality}</div>
                        <div class="health-card-details">
                            <div>Stability: ${stabilityQuality}</div>
                            <div>${data.transitions.last_24h < 10 ? 'Very stable' : 
                                       data.transitions.last_24h < 20 ? 'Stable' :
                                       'Check propagation'}</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function renderChannelTable(data) {
            // Sort channels by frequency
            const sortedChannels = window.GRAPE_UTILS.sortByChannelFrequency(data.channels, 'channel');
            const rows = sortedChannels.map(ch => {
                const healthClass = ch.health_score >= 90 ? 'excellent' :
                                   ch.health_score >= 70 ? 'good' :
                                   ch.health_score >= 50 ? 'fair' : 'poor';
                
                const qualityClass = ch.quality.toLowerCase().replace('_', '-');
                
                // Format jitter - show "stabilizing" if > 1000ms
                const jitterDisplay = ch.jitter_ms > 1000 ? 
                    '<span style="color: #94a3b8;">stabilizing</span>' :
                    `${ch.jitter_ms.toFixed(3)} ms`;
                
                // Format drift - highlight if significant
                const driftDisplay = Math.abs(ch.drift_ms) > 10 ?
                    `<span style="color: #ef4444;">${ch.drift_ms.toFixed(3)} ms</span>` :
                    `${ch.drift_ms.toFixed(3)} ms`;
                
                return `
                    <tr>
                        <td><strong>${ch.channel}</strong></td>
                        <td><span class="quality-badge ${qualityClass}">${ch.quality}</span></td>
                        <td style="text-align: right;">${driftDisplay}</td>
                        <td style="text-align: right;">${jitterDisplay}</td>
                        <td><span class="health-score ${healthClass}">${ch.health_score}/100</span></td>
                    </tr>
                `;
            }).join('');
            
            return `
                <div class="channel-table-container">
                    <div class="chart-header">üìã Per-Channel Timing Detail</div>
                    <table>
                        <thead>
                            <tr>
                                <th>Channel</th>
                                <th>Quality</th>
                                <th>Drift</th>
                                <th>Jitter</th>
                                <th>Health Score</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>
                </div>
            `;
        }
        
        function renderChartPlaceholders() {
            return `
                <div class="chart-section">
                    <div class="chart-header">
                        üìà RTP Drift Analysis
                        <select id="drift-channel-select" onchange="loadDriftChart()" style="margin-left: 20px; padding: 5px 10px; background: #1e293b; color: #e0e0e0; border: 1px solid #334155; border-radius: 4px;">
                            <option value="all">All Channels</option>
                        </select>
                        <select id="drift-hours-select" onchange="loadDriftChart()" style="margin-left: 10px; padding: 5px 10px; background: #1e293b; color: #e0e0e0; border: 1px solid #334155; border-radius: 4px;">
                            <option value="1">Last 1 Hour</option>
                            <option value="6">Last 6 Hours</option>
                            <option value="24" selected>Last 24 Hours</option>
                        </select>
                    </div>
                    <div class="chart-container" id="drift-chart" style="height: 350px;"></div>
                </div>
                
                <div class="chart-section">
                    <div class="chart-header">
                        üïê Time Source Timeline
                        <select id="timeline-hours-select" onchange="loadTimelineChart()" style="margin-left: 20px; padding: 5px 10px; background: #1e293b; color: #e0e0e0; border: 1px solid #334155; border-radius: 4px;">
                            <option value="6">Last 6 Hours</option>
                            <option value="12">Last 12 Hours</option>
                            <option value="24" selected>Last 24 Hours</option>
                        </select>
                    </div>
                    <div class="chart-container" id="timeline-chart" style="height: 400px;"></div>
                </div>
                
                <!-- Quality Level Legend -->
                <div class="chart-section" style="padding: 20px 25px;">
                    <div class="chart-header" style="margin-bottom: 15px;">üìñ Time Quality Levels</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                        <div style="display: flex; align-items: flex-start; gap: 12px;">
                            <span style="background: #10b981; color: #fff; padding: 4px 12px; border-radius: 12px; font-weight: 600; font-size: 12px; white-space: nowrap;">TONE_LOCKED</span>
                            <span style="color: #cbd5e1; font-size: 13px; line-height: 1.4;">Fresh tone detection (&lt;5 min). Highest precision (¬±1ms). Time derived from WWV/CHU tone edge at minute boundary.</span>
                        </div>
                        <div style="display: flex; align-items: flex-start; gap: 12px;">
                            <span style="background: #22c55e; color: #fff; padding: 4px 12px; border-radius: 12px; font-weight: 600; font-size: 12px; white-space: nowrap;">TONE_STABLE</span>
                            <span style="color: #cbd5e1; font-size: 13px; line-height: 1.4;">Aged tone reference with excellent RTP drift (&lt;1ms). Precision still good despite age - ADC clock is tracking well.</span>
                        </div>
                        <div style="display: flex; align-items: flex-start; gap: 12px;">
                            <span style="background: #f59e0b; color: #fff; padding: 4px 12px; border-radius: 12px; font-weight: 600; font-size: 12px; white-space: nowrap;">TONE_AGED</span>
                            <span style="color: #cbd5e1; font-size: 13px; line-height: 1.4;">Aged tone reference (>5 min). Precision degrades ~1ms/hour as ADC clock drifts. Still better than NTP if recent.</span>
                        </div>
                        <div style="display: flex; align-items: flex-start; gap: 12px;">
                            <span style="background: #3b82f6; color: #fff; padding: 4px 12px; border-radius: 12px; font-weight: 600; font-size: 12px; white-space: nowrap;">NTP_SYNCED</span>
                            <span style="color: #cbd5e1; font-size: 13px; line-height: 1.4;">Using NTP-synchronized system clock. Good precision (¬±10ms). Fallback when no tone available.</span>
                        </div>
                        <div style="display: flex; align-items: flex-start; gap: 12px;">
                            <span style="background: #ef4444; color: #fff; padding: 4px 12px; border-radius: 12px; font-weight: 600; font-size: 12px; white-space: nowrap;">WALL_CLOCK</span>
                            <span style="color: #cbd5e1; font-size: 13px; line-height: 1.4;">Unsynchronized system clock. Low precision (¬±seconds). Only at startup before first tone detection.</span>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding: 12px; background: rgba(16, 185, 129, 0.1); border-radius: 6px; font-size: 13px; color: #10b981;">
                        üí° <strong>Key insight:</strong> RTP drift is the true measure of timing quality. If drift is &lt;1ms, timing is excellent regardless of how old the tone reference is.
                    </div>
                </div>
            `;
        }
        
        function renderTransitions(data) {
            if (data.count === 0) {
                return `
                    <div class="transitions-section">
                        <div class="chart-header">üîÑ Recent Time Source Transitions</div>
                        <div style="text-align: center; padding: 40px; color: #10b981;">
                            ‚úÖ No transitions in the last 24 hours - excellent stability!
                        </div>
                    </div>
                `;
            }
            
            const items = data.transitions.slice(0, 10).map(t => {
                return `
                    <div class="transition-item">
                        <div class="transition-time">${new Date(t.timestamp).toLocaleString()}</div>
                        <div class="transition-title">
                            ${t.channel}: ${t.from_quality} ‚Üí ${t.to_quality}
                        </div>
                        <div class="transition-details">
                            ‚îú‚îÄ Reason: ${t.reason}<br>
                            ${t.last_snr_db ? `‚îú‚îÄ Last SNR: ${t.last_snr_db.toFixed(1)} dB<br>` : ''}
                            ‚îú‚îÄ Previous duration: ${t.duration_on_previous_source_minutes.toFixed(0)} minutes<br>
                            ‚îî‚îÄ Source: ${t.from_source} ‚Üí ${t.to_source}
                        </div>
                    </div>
                `;
            }).join('');
            
            return `
                <div class="transitions-section">
                    <div class="chart-header">üîÑ Recent Time Source Transitions (Last 24h: ${data.count})</div>
                    ${items}
                </div>
            `;
        }
        
        // Store channel list for dropdown population
        let availableChannels = [];
        
        function loadCharts() {
            // Populate channel dropdown from health summary
            populateChannelDropdown();
            // Load both charts
            loadDriftChart();
            loadTimelineChart();
        }
        
        function populateChannelDropdown() {
            const select = document.getElementById('drift-channel-select');
            if (!select || availableChannels.length === 0) return;
            
            // Keep "All Channels" option
            select.innerHTML = '<option value="all">All Channels</option>';
            
            // Add each channel
            availableChannels.forEach(ch => {
                const option = document.createElement('option');
                option.value = ch;
                option.textContent = ch;
                select.appendChild(option);
            });
        }
        
        async function loadDriftChart() {
            const channelSelect = document.getElementById('drift-channel-select');
            const hoursSelect = document.getElementById('drift-hours-select');
            const chartDiv = document.getElementById('drift-chart');
            
            if (!chartDiv) return;
            
            const hours = hoursSelect ? parseInt(hoursSelect.value) : 24;
            const selectedChannel = channelSelect ? channelSelect.value : 'all';
            const today = new Date().toISOString().split('T')[0].replace(/-/g, '');
            
            try {
                // Fetch metrics for all channels or selected channel
                const channelsToFetch = selectedChannel === 'all' ? availableChannels : [selectedChannel];
                const traces = [];
                const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16', '#f97316'];
                
                for (let i = 0; i < channelsToFetch.length; i++) {
                    const channel = channelsToFetch[i];
                    try {
                        const response = await fetch(`/api/v1/timing/metrics?channel=${encodeURIComponent(channel)}&date=${today}&hours=${hours}`);
                        const data = await response.json();
                        
                        if (data.available && data.metrics && data.metrics.length > 0) {
                            const x = data.metrics.map(m => new Date(m.timestamp));
                            const y = data.metrics.map(m => m.drift_ms);
                            
                            traces.push({
                                x: x,
                                y: y,
                                mode: 'lines+markers',
                                name: channel,
                                line: { color: colors[i % colors.length], width: 2 },
                                marker: { size: 4 }
                            });
                        }
                    } catch (err) {
                        console.warn(`Failed to load drift data for ${channel}:`, err);
                    }
                }
                
                // Add reference bands
                const shapes = [
                    // Excellent band (¬±1ms)
                    { type: 'rect', xref: 'paper', yref: 'y', x0: 0, x1: 1, y0: -1, y1: 1,
                      fillcolor: 'rgba(16, 185, 129, 0.1)', line: { width: 0 } },
                    // Good band (¬±5ms)
                    { type: 'rect', xref: 'paper', yref: 'y', x0: 0, x1: 1, y0: -5, y1: -1,
                      fillcolor: 'rgba(59, 130, 246, 0.05)', line: { width: 0 } },
                    { type: 'rect', xref: 'paper', yref: 'y', x0: 0, x1: 1, y0: 1, y1: 5,
                      fillcolor: 'rgba(59, 130, 246, 0.05)', line: { width: 0 } }
                ];
                
                const layout = {
                    paper_bgcolor: '#0f172a',
                    plot_bgcolor: '#0f172a',
                    font: { color: '#e0e0e0', size: 12 },
                    xaxis: { 
                        gridcolor: '#334155',
                        title: 'Time (UTC)',
                        tickformat: '%H:%M'
                    },
                    yaxis: { 
                        gridcolor: '#334155', 
                        title: 'Drift (ms)',
                        zeroline: true,
                        zerolinecolor: '#64748b',
                        zerolinewidth: 2
                    },
                    margin: { t: 30, r: 30, b: 50, l: 60 },
                    legend: { 
                        orientation: 'h', 
                        y: -0.15,
                        font: { size: 10 }
                    },
                    shapes: shapes,
                    hovermode: 'x unified'
                };
                
                if (traces.length === 0) {
                    chartDiv.innerHTML = '<div style="text-align: center; padding: 60px; color: #94a3b8;">No drift data available for selected time range</div>';
                } else {
                    Plotly.newPlot('drift-chart', traces, layout, {responsive: true});
                }
                
            } catch (error) {
                console.error('Error loading drift chart:', error);
                chartDiv.innerHTML = `<div style="text-align: center; padding: 60px; color: #ef4444;">Failed to load drift data: ${error.message}</div>`;
            }
        }
        
        async function loadTimelineChart() {
            const hoursSelect = document.getElementById('timeline-hours-select');
            const chartDiv = document.getElementById('timeline-chart');
            
            if (!chartDiv) return;
            
            const hours = hoursSelect ? parseInt(hoursSelect.value) : 24;
            const today = new Date().toISOString().split('T')[0].replace(/-/g, '');
            
            try {
                // Fetch metrics for all channels to build timeline
                const traces = [];
                const qualityColors = {
                    'TONE_LOCKED': '#10b981',
                    'TONE_STABLE': '#22c55e',
                    'TONE_AGED': '#f59e0b',
                    'NTP_SYNCED': '#3b82f6',
                    'INTERPOLATED': '#f59e0b',  // Legacy name
                    'WALL_CLOCK': '#ef4444'
                };
                
                for (let i = 0; i < availableChannels.length; i++) {
                    const channel = availableChannels[i];
                    try {
                        const response = await fetch(`/api/v1/timing/metrics?channel=${encodeURIComponent(channel)}&date=${today}&hours=${hours}`);
                        const data = await response.json();
                        
                        if (data.available && data.metrics && data.metrics.length > 0) {
                            // Group consecutive records by quality
                            const segments = [];
                            let currentSegment = null;
                            
                            for (const m of data.metrics) {
                                if (!currentSegment || currentSegment.quality !== m.quality) {
                                    if (currentSegment) {
                                        currentSegment.end = new Date(m.timestamp);
                                        segments.push(currentSegment);
                                    }
                                    currentSegment = {
                                        quality: m.quality,
                                        start: new Date(m.timestamp),
                                        end: null
                                    };
                                }
                            }
                            if (currentSegment) {
                                currentSegment.end = new Date();
                                segments.push(currentSegment);
                            }
                            
                            // Create a trace for each quality type for this channel
                            for (const quality of Object.keys(qualityColors)) {
                                const qualitySegments = segments.filter(s => s.quality === quality);
                                if (qualitySegments.length > 0) {
                                    for (const seg of qualitySegments) {
                                        traces.push({
                                            x: [seg.start, seg.end],
                                            y: [channel, channel],
                                            mode: 'lines',
                                            line: { color: qualityColors[quality], width: 20 },
                                            name: quality,
                                            legendgroup: quality,
                                            showlegend: traces.filter(t => t.legendgroup === quality).length === 0,
                                            hovertemplate: `${channel}<br>${quality}<br>%{x}<extra></extra>`
                                        });
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        console.warn(`Failed to load timeline data for ${channel}:`, err);
                    }
                }
                
                // Calculate the time range for the X-axis to show full span
                const now = new Date();
                const rangeEnd = now;
                const rangeStart = new Date(now.getTime() - hours * 60 * 60 * 1000);
                
                const layout = {
                    paper_bgcolor: '#0f172a',
                    plot_bgcolor: '#0f172a',
                    font: { color: '#e0e0e0', size: 12 },
                    xaxis: { 
                        gridcolor: '#334155',
                        title: 'Time (UTC)',
                        tickformat: '%H:%M',
                        range: [rangeStart, rangeEnd]
                    },
                    yaxis: { 
                        gridcolor: '#334155',
                        title: '',
                        automargin: true
                    },
                    margin: { t: 30, r: 30, b: 50, l: 120 },
                    legend: { 
                        orientation: 'h', 
                        y: -0.12,
                        font: { size: 11 }
                    },
                    hovermode: 'closest',
                    barmode: 'overlay'
                };
                
                if (traces.length === 0) {
                    chartDiv.innerHTML = '<div style="text-align: center; padding: 60px; color: #94a3b8;">No timeline data available for selected time range</div>';
                } else {
                    Plotly.newPlot('timeline-chart', traces, layout, {responsive: true});
                }
                
            } catch (error) {
                console.error('Error loading timeline chart:', error);
                chartDiv.innerHTML = `<div style="text-align: center; padding: 60px; color: #ef4444;">Failed to load timeline data: ${error.message}</div>`;
            }
        }
        
        function checkAlerts(primaryRef, healthSummary) {
            const banner = document.getElementById('alert-banner');
            const title = document.getElementById('alert-title');
            const message = document.getElementById('alert-message');
            
            const avgDrift = parseFloat(healthSummary.drift.average_ms);
            const isToneBased = primaryRef.is_tone_based || 
                               primaryRef.source_type?.includes('startup') ||
                               primaryRef.source_type?.includes('wwv') ||
                               primaryRef.source_type?.includes('chu');
            
            // Check for critical issues
            if (!primaryRef.available) {
                banner.className = 'alert-banner visible';
                title.textContent = 'Critical: No Time Reference';
                message.textContent = 'No time reference available. Check core recorder and tone detection.';
                return;
            }
            
            // Wall clock with no tone history is critical
            if (primaryRef.quality === 'WALL_CLOCK' && !isToneBased) {
                banner.className = 'alert-banner visible';
                title.textContent = 'Critical: Using Unsynchronized Clock';
                message.textContent = 'No tone reference established. Timing precision is ¬±seconds. Check propagation and tone detection.';
                return;
            }
            
            // Excessive drift is always critical regardless of source
            if (avgDrift > 50) {
                banner.className = 'alert-banner visible';
                title.textContent = 'Critical: Excessive Drift';
                message.textContent = `Average drift is ${healthSummary.drift.average_ms}ms. Check system clock and RTP streams.`;
                return;
            }
            
            // Tone-based timing with good drift - no warning needed!
            // This was the key missing case
            if (isToneBased && avgDrift < 5) {
                // No alert - everything is working well
                banner.className = 'alert-banner';
                return;
            }
            
            // NTP-only with no tone-based channels is a soft warning
            if (!isToneBased && healthSummary.tone_locked_channels === 0) {
                banner.className = 'alert-banner visible warning';
                title.textContent = 'Info: Using NTP Timing';
                message.textContent = `All channels using NTP (¬±10ms). No tone detected yet - normal during poor propagation. RTP drift: ¬±${avgDrift.toFixed(2)}ms`;
                return;
            }
            
            // System stabilizing after startup
            if (primaryRef.age_seconds < 120) {
                banner.className = 'alert-banner visible warning';
                title.textContent = 'Info: System Stabilizing';
                message.textContent = 'Recently started - timing measurements stabilizing. Data quality will improve.';
                return;
            }
            
            // No critical alerts
            banner.className = 'alert-banner';
        }
        
        function formatAge(seconds) {
            if (seconds < 0) return '0s';
            const s = Math.floor(seconds);
            if (s < 60) return `${s}s`;
            if (s < 3600) return `${Math.floor(s/60)}m ${s%60}s`;
            return `${Math.floor(s/3600)}h ${Math.floor((s%3600)/60)}m`;
        }
        
        // Initialize
        loadDashboard();
        startAutoRefresh();
    </script>
    </div><!-- end container -->
    <script src="/components/theme-toggle.js"></script>
    <script src="/components/navigation.js"></script>
</body>
</html>
